// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(restsendFFI)
import restsendFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_client_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_client_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public protocol ClientProtocol {
    func `setCallback`(`callback`: Callback?)  
    func `setUploader`(`uploader`: Uploader?)  
    func `prepare`()  throws
    func `attach`(`info`: AuthInfo)  throws
    func `appActive`()  
    func `appDeactivate`()  
    func `logout`()  throws
    func `runLoop`()  throws
    func `shutdown`()  throws
    func `getNetworkState`()   -> NetworkState
    func `getTopicsKnockCount`()  throws -> UInt32
    func `getConversationsCount`()  throws -> UInt32
    func `getConversation`(`topicId`: String)  throws -> Conversation
    func `removeConversation`(`topicId`: String)  throws
    func `setConversationSticky`(`topicId`: String, `sticky`: Bool)  throws
    func `setConversationMute`(`topicId`: String, `mute`: Bool)  throws
    func `setConversationRead`(`topicId`: String)  throws
    func `getConversations`(`updatedAt`: String, `limit`: UInt32)  throws -> ListConversationResult
    func `syncConversations`(`withoutCache`: Bool)  throws
    func `getTopic`(`topicId`: String)  throws -> Topic
    func `getTopicAdmins`(`topicId`: String)  throws -> [User]
    func `getTopicOwner`(`topicId`: String)  throws -> User
    func `getTopicMembers`(`topicId`: String, `updatedAt`: String, `limit`: UInt32)  throws -> ListUserResult
    func `getChatLogsDesc`(`topicId`: String, `startSeq`: UInt64, `endSeq`: UInt64)  throws -> ListChatLogResult
    func `getChatLog`(`topicId`: String, `id`: String)  throws -> ChatLog
    func `searchChatLog`(`topicId`: String, `senderId`: String, `keyword`: String)  throws -> [ChatLog]
    func `getTopicKnocks`(`topicId`: String)  throws -> [TopicKnock]
    func `createTopic`(`name`: String, `icon`: String, `members`: [String])  throws -> Topic
    func `createChat`(`userId`: String)  throws -> Topic
    func `updateTopic`(`topicId`: String, `name`: String, `icon`: String)  throws
    func `updateTopicNotice`(`topicId`: String, `text`: String)  throws
    func `silentTopic`(`topicId`: String, `duration`: String)  throws
    func `silentTopicMember`(`topicId`: String, `userId`: String, `duration`: String)  throws
    func `addTopicAdmin`(`topicId`: String, `userId`: String)  throws
    func `removeTopicAdmin`(`topicId`: String, `userId`: String)  throws
    func `transferTopic`(`topicId`: String, `userId`: String)  throws
    func `quitTopic`(`topicId`: String)  throws
    func `dismissTopic`(`topicId`: String)  throws
    func `joinTopic`(`topicId`: String, `source`: String, `message`: String)  throws
    func `acceptTopicJoin`(`topicId`: String, `userId`: String, `memo`: String)  throws
    func `declineTopicJoin`(`topicId`: String, `userId`: String, `message`: String)  throws
    func `inviteTopicMember`(`topicId`: String, `userId`: String)  throws
    func `removeTopicMember`(`topicId`: String, `userId`: String)  throws
    func `cleanTopicHistory`(`topicId`: String, `sync`: Bool)  throws
    func `removeMessages`(`topicId`: String, `chatIds`: [String], `sync`: Bool)  throws
    func `getUser`(`userId`: String)  throws -> User
    func `setUserRemark`(`userId`: String, `remark`: String)  throws
    func `setUserStar`(`userId`: String, `star`: Bool)  throws
    func `setUserBlock`(`userId`: String, `block`: Bool)  throws
    func `setAllowGuestChat`(`allow`: Bool)  throws
    func `doTyping`(`topicId`: String)  throws -> String
    func `doRecall`(`topicId`: String, `chatId`: String)  throws -> String
    func `doSendText`(`topicId`: String, `text`: String, `mentions`: [String]?, `replyId`: String?)  throws -> String
    func `doSendImage`(`topicId`: String, `urlOrData`: String, `mentions`: [String]?, `replyId`: String?)  throws -> String
    func `doSendVoice`(`topicId`: String, `urlOrData`: String, `duration`: String, `mentions`: [String]?, `replyId`: String?)  throws -> String
    func `doSendVideo`(`topicId`: String, `url`: String, `thumbnail`: String, `duration`: String, `mentions`: [String]?, `replyId`: String?)  throws -> String
    func `doSendFile`(`topicId`: String, `urlOrData`: String, `filename`: String, `size`: UInt64, `mentions`: [String]?, `replyId`: String?)  throws -> String
    func `doSendLocation`(`topicId`: String, `latitude`: String, `longitude`: String, `address`: String, `mentions`: [String]?, `replyId`: String?)  throws -> String
    func `doSendLink`(`topicId`: String, `url`: String, `mentions`: [String]?, `replyId`: String?)  throws -> String
    func `doSend`(`topicId`: String, `content`: Content)  throws -> String
    func `upload`(`uploaderUrl`: String?, `localFilePath`: String, `key`: String, `isPrivate`: Bool)  throws
    func `download`(`fileUrl`: String, `saveTo`: String, `key`: String)  throws
    func `cancelDownload`(`fileUrl`: String, `key`: String)  throws
    func `cancelUpload`(`localFilePath`: String, `key`: String)  throws
    
}

public class Client: ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(`dbName`: String, `endpoint`: String)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_client_fn_constructor_client_new(
        FfiConverterString.lower(`dbName`),
        FfiConverterString.lower(`endpoint`),$0)
})
    }

    deinit {
        try! rustCall { uniffi_client_fn_free_client(pointer, $0) }
    }

    

    
    

    public func `setCallback`(`callback`: Callback?)  {
        try! 
    rustCall() {
    
    uniffi_client_fn_method_client_set_callback(self.pointer, 
        FfiConverterOptionCallbackInterfaceCallback.lower(`callback`),$0
    )
}
    }

    public func `setUploader`(`uploader`: Uploader?)  {
        try! 
    rustCall() {
    
    uniffi_client_fn_method_client_set_uploader(self.pointer, 
        FfiConverterOptionCallbackInterfaceUploader.lower(`uploader`),$0
    )
}
    }

    public func `prepare`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_prepare(self.pointer, $0
    )
}
    }

    public func `attach`(`info`: AuthInfo) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_attach(self.pointer, 
        FfiConverterTypeAuthInfo.lower(`info`),$0
    )
}
    }

    public func `appActive`()  {
        try! 
    rustCall() {
    
    uniffi_client_fn_method_client_app_active(self.pointer, $0
    )
}
    }

    public func `appDeactivate`()  {
        try! 
    rustCall() {
    
    uniffi_client_fn_method_client_app_deactivate(self.pointer, $0
    )
}
    }

    public func `logout`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_logout(self.pointer, $0
    )
}
    }

    public func `runLoop`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_run_loop(self.pointer, $0
    )
}
    }

    public func `shutdown`() throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_shutdown(self.pointer, $0
    )
}
    }

    public func `getNetworkState`()  -> NetworkState {
        return try!  FfiConverterTypeNetworkState.lift(
            try! 
    rustCall() {
    
    uniffi_client_fn_method_client_get_network_state(self.pointer, $0
    )
}
        )
    }

    public func `getTopicsKnockCount`() throws -> UInt32 {
        return try  FfiConverterUInt32.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_get_topics_knock_count(self.pointer, $0
    )
}
        )
    }

    public func `getConversationsCount`() throws -> UInt32 {
        return try  FfiConverterUInt32.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_get_conversations_count(self.pointer, $0
    )
}
        )
    }

    public func `getConversation`(`topicId`: String) throws -> Conversation {
        return try  FfiConverterTypeConversation.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_get_conversation(self.pointer, 
        FfiConverterString.lower(`topicId`),$0
    )
}
        )
    }

    public func `removeConversation`(`topicId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_remove_conversation(self.pointer, 
        FfiConverterString.lower(`topicId`),$0
    )
}
    }

    public func `setConversationSticky`(`topicId`: String, `sticky`: Bool) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_set_conversation_sticky(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterBool.lower(`sticky`),$0
    )
}
    }

    public func `setConversationMute`(`topicId`: String, `mute`: Bool) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_set_conversation_mute(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterBool.lower(`mute`),$0
    )
}
    }

    public func `setConversationRead`(`topicId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_set_conversation_read(self.pointer, 
        FfiConverterString.lower(`topicId`),$0
    )
}
    }

    public func `getConversations`(`updatedAt`: String, `limit`: UInt32) throws -> ListConversationResult {
        return try  FfiConverterTypeListConversationResult.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_get_conversations(self.pointer, 
        FfiConverterString.lower(`updatedAt`),
        FfiConverterUInt32.lower(`limit`),$0
    )
}
        )
    }

    public func `syncConversations`(`withoutCache`: Bool) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_sync_conversations(self.pointer, 
        FfiConverterBool.lower(`withoutCache`),$0
    )
}
    }

    public func `getTopic`(`topicId`: String) throws -> Topic {
        return try  FfiConverterTypeTopic.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_get_topic(self.pointer, 
        FfiConverterString.lower(`topicId`),$0
    )
}
        )
    }

    public func `getTopicAdmins`(`topicId`: String) throws -> [User] {
        return try  FfiConverterSequenceTypeUser.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_get_topic_admins(self.pointer, 
        FfiConverterString.lower(`topicId`),$0
    )
}
        )
    }

    public func `getTopicOwner`(`topicId`: String) throws -> User {
        return try  FfiConverterTypeUser.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_get_topic_owner(self.pointer, 
        FfiConverterString.lower(`topicId`),$0
    )
}
        )
    }

    public func `getTopicMembers`(`topicId`: String, `updatedAt`: String, `limit`: UInt32) throws -> ListUserResult {
        return try  FfiConverterTypeListUserResult.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_get_topic_members(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`updatedAt`),
        FfiConverterUInt32.lower(`limit`),$0
    )
}
        )
    }

    public func `getChatLogsDesc`(`topicId`: String, `startSeq`: UInt64, `endSeq`: UInt64) throws -> ListChatLogResult {
        return try  FfiConverterTypeListChatLogResult.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_get_chat_logs_desc(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterUInt64.lower(`startSeq`),
        FfiConverterUInt64.lower(`endSeq`),$0
    )
}
        )
    }

    public func `getChatLog`(`topicId`: String, `id`: String) throws -> ChatLog {
        return try  FfiConverterTypeChatLog.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_get_chat_log(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`id`),$0
    )
}
        )
    }

    public func `searchChatLog`(`topicId`: String, `senderId`: String, `keyword`: String) throws -> [ChatLog] {
        return try  FfiConverterSequenceTypeChatLog.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_search_chat_log(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`senderId`),
        FfiConverterString.lower(`keyword`),$0
    )
}
        )
    }

    public func `getTopicKnocks`(`topicId`: String) throws -> [TopicKnock] {
        return try  FfiConverterSequenceTypeTopicKnock.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_get_topic_knocks(self.pointer, 
        FfiConverterString.lower(`topicId`),$0
    )
}
        )
    }

    public func `createTopic`(`name`: String, `icon`: String, `members`: [String]) throws -> Topic {
        return try  FfiConverterTypeTopic.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_create_topic(self.pointer, 
        FfiConverterString.lower(`name`),
        FfiConverterString.lower(`icon`),
        FfiConverterSequenceString.lower(`members`),$0
    )
}
        )
    }

    public func `createChat`(`userId`: String) throws -> Topic {
        return try  FfiConverterTypeTopic.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_create_chat(self.pointer, 
        FfiConverterString.lower(`userId`),$0
    )
}
        )
    }

    public func `updateTopic`(`topicId`: String, `name`: String, `icon`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_update_topic(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`name`),
        FfiConverterString.lower(`icon`),$0
    )
}
    }

    public func `updateTopicNotice`(`topicId`: String, `text`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_update_topic_notice(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`text`),$0
    )
}
    }

    public func `silentTopic`(`topicId`: String, `duration`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_silent_topic(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`duration`),$0
    )
}
    }

    public func `silentTopicMember`(`topicId`: String, `userId`: String, `duration`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_silent_topic_member(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`userId`),
        FfiConverterString.lower(`duration`),$0
    )
}
    }

    public func `addTopicAdmin`(`topicId`: String, `userId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_add_topic_admin(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`userId`),$0
    )
}
    }

    public func `removeTopicAdmin`(`topicId`: String, `userId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_remove_topic_admin(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`userId`),$0
    )
}
    }

    public func `transferTopic`(`topicId`: String, `userId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_transfer_topic(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`userId`),$0
    )
}
    }

    public func `quitTopic`(`topicId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_quit_topic(self.pointer, 
        FfiConverterString.lower(`topicId`),$0
    )
}
    }

    public func `dismissTopic`(`topicId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_dismiss_topic(self.pointer, 
        FfiConverterString.lower(`topicId`),$0
    )
}
    }

    public func `joinTopic`(`topicId`: String, `source`: String, `message`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_join_topic(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`source`),
        FfiConverterString.lower(`message`),$0
    )
}
    }

    public func `acceptTopicJoin`(`topicId`: String, `userId`: String, `memo`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_accept_topic_join(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`userId`),
        FfiConverterString.lower(`memo`),$0
    )
}
    }

    public func `declineTopicJoin`(`topicId`: String, `userId`: String, `message`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_decline_topic_join(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`userId`),
        FfiConverterString.lower(`message`),$0
    )
}
    }

    public func `inviteTopicMember`(`topicId`: String, `userId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_invite_topic_member(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`userId`),$0
    )
}
    }

    public func `removeTopicMember`(`topicId`: String, `userId`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_remove_topic_member(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`userId`),$0
    )
}
    }

    public func `cleanTopicHistory`(`topicId`: String, `sync`: Bool) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_clean_topic_history(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterBool.lower(`sync`),$0
    )
}
    }

    public func `removeMessages`(`topicId`: String, `chatIds`: [String], `sync`: Bool) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_remove_messages(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterSequenceString.lower(`chatIds`),
        FfiConverterBool.lower(`sync`),$0
    )
}
    }

    public func `getUser`(`userId`: String) throws -> User {
        return try  FfiConverterTypeUser.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_get_user(self.pointer, 
        FfiConverterString.lower(`userId`),$0
    )
}
        )
    }

    public func `setUserRemark`(`userId`: String, `remark`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_set_user_remark(self.pointer, 
        FfiConverterString.lower(`userId`),
        FfiConverterString.lower(`remark`),$0
    )
}
    }

    public func `setUserStar`(`userId`: String, `star`: Bool) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_set_user_star(self.pointer, 
        FfiConverterString.lower(`userId`),
        FfiConverterBool.lower(`star`),$0
    )
}
    }

    public func `setUserBlock`(`userId`: String, `block`: Bool) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_set_user_block(self.pointer, 
        FfiConverterString.lower(`userId`),
        FfiConverterBool.lower(`block`),$0
    )
}
    }

    public func `setAllowGuestChat`(`allow`: Bool) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_set_allow_guest_chat(self.pointer, 
        FfiConverterBool.lower(`allow`),$0
    )
}
    }

    public func `doTyping`(`topicId`: String) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_do_typing(self.pointer, 
        FfiConverterString.lower(`topicId`),$0
    )
}
        )
    }

    public func `doRecall`(`topicId`: String, `chatId`: String) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_do_recall(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`chatId`),$0
    )
}
        )
    }

    public func `doSendText`(`topicId`: String, `text`: String, `mentions`: [String]?, `replyId`: String?) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_do_send_text(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`text`),
        FfiConverterOptionSequenceString.lower(`mentions`),
        FfiConverterOptionString.lower(`replyId`),$0
    )
}
        )
    }

    public func `doSendImage`(`topicId`: String, `urlOrData`: String, `mentions`: [String]?, `replyId`: String?) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_do_send_image(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`urlOrData`),
        FfiConverterOptionSequenceString.lower(`mentions`),
        FfiConverterOptionString.lower(`replyId`),$0
    )
}
        )
    }

    public func `doSendVoice`(`topicId`: String, `urlOrData`: String, `duration`: String, `mentions`: [String]?, `replyId`: String?) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_do_send_voice(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`urlOrData`),
        FfiConverterString.lower(`duration`),
        FfiConverterOptionSequenceString.lower(`mentions`),
        FfiConverterOptionString.lower(`replyId`),$0
    )
}
        )
    }

    public func `doSendVideo`(`topicId`: String, `url`: String, `thumbnail`: String, `duration`: String, `mentions`: [String]?, `replyId`: String?) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_do_send_video(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`url`),
        FfiConverterString.lower(`thumbnail`),
        FfiConverterString.lower(`duration`),
        FfiConverterOptionSequenceString.lower(`mentions`),
        FfiConverterOptionString.lower(`replyId`),$0
    )
}
        )
    }

    public func `doSendFile`(`topicId`: String, `urlOrData`: String, `filename`: String, `size`: UInt64, `mentions`: [String]?, `replyId`: String?) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_do_send_file(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`urlOrData`),
        FfiConverterString.lower(`filename`),
        FfiConverterUInt64.lower(`size`),
        FfiConverterOptionSequenceString.lower(`mentions`),
        FfiConverterOptionString.lower(`replyId`),$0
    )
}
        )
    }

    public func `doSendLocation`(`topicId`: String, `latitude`: String, `longitude`: String, `address`: String, `mentions`: [String]?, `replyId`: String?) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_do_send_location(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`latitude`),
        FfiConverterString.lower(`longitude`),
        FfiConverterString.lower(`address`),
        FfiConverterOptionSequenceString.lower(`mentions`),
        FfiConverterOptionString.lower(`replyId`),$0
    )
}
        )
    }

    public func `doSendLink`(`topicId`: String, `url`: String, `mentions`: [String]?, `replyId`: String?) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_do_send_link(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterString.lower(`url`),
        FfiConverterOptionSequenceString.lower(`mentions`),
        FfiConverterOptionString.lower(`replyId`),$0
    )
}
        )
    }

    public func `doSend`(`topicId`: String, `content`: Content) throws -> String {
        return try  FfiConverterString.lift(
            try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_do_send(self.pointer, 
        FfiConverterString.lower(`topicId`),
        FfiConverterTypeContent.lower(`content`),$0
    )
}
        )
    }

    public func `upload`(`uploaderUrl`: String?, `localFilePath`: String, `key`: String, `isPrivate`: Bool) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_upload(self.pointer, 
        FfiConverterOptionString.lower(`uploaderUrl`),
        FfiConverterString.lower(`localFilePath`),
        FfiConverterString.lower(`key`),
        FfiConverterBool.lower(`isPrivate`),$0
    )
}
    }

    public func `download`(`fileUrl`: String, `saveTo`: String, `key`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_download(self.pointer, 
        FfiConverterString.lower(`fileUrl`),
        FfiConverterString.lower(`saveTo`),
        FfiConverterString.lower(`key`),$0
    )
}
    }

    public func `cancelDownload`(`fileUrl`: String, `key`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_cancel_download(self.pointer, 
        FfiConverterString.lower(`fileUrl`),
        FfiConverterString.lower(`key`),$0
    )
}
    }

    public func `cancelUpload`(`localFilePath`: String, `key`: String) throws {
        try 
    rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_method_client_cancel_upload(self.pointer, 
        FfiConverterString.lower(`localFilePath`),
        FfiConverterString.lower(`key`),$0
    )
}
    }
}

public struct FfiConverterTypeClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}


public struct AuthInfo {
    public var `endpoint`: String
    public var `userId`: String
    public var `avatar`: String
    public var `name`: String
    public var `token`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`endpoint`: String, `userId`: String, `avatar`: String, `name`: String, `token`: String) {
        self.`endpoint` = `endpoint`
        self.`userId` = `userId`
        self.`avatar` = `avatar`
        self.`name` = `name`
        self.`token` = `token`
    }
}


extension AuthInfo: Equatable, Hashable {
    public static func ==(lhs: AuthInfo, rhs: AuthInfo) -> Bool {
        if lhs.`endpoint` != rhs.`endpoint` {
            return false
        }
        if lhs.`userId` != rhs.`userId` {
            return false
        }
        if lhs.`avatar` != rhs.`avatar` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`token` != rhs.`token` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`endpoint`)
        hasher.combine(`userId`)
        hasher.combine(`avatar`)
        hasher.combine(`name`)
        hasher.combine(`token`)
    }
}


public struct FfiConverterTypeAuthInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthInfo {
        return try AuthInfo(
            `endpoint`: FfiConverterString.read(from: &buf), 
            `userId`: FfiConverterString.read(from: &buf), 
            `avatar`: FfiConverterString.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `token`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AuthInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`endpoint`, into: &buf)
        FfiConverterString.write(value.`userId`, into: &buf)
        FfiConverterString.write(value.`avatar`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`token`, into: &buf)
    }
}


public func FfiConverterTypeAuthInfo_lift(_ buf: RustBuffer) throws -> AuthInfo {
    return try FfiConverterTypeAuthInfo.lift(buf)
}

public func FfiConverterTypeAuthInfo_lower(_ value: AuthInfo) -> RustBuffer {
    return FfiConverterTypeAuthInfo.lower(value)
}


public struct ChatLog {
    public var `topicId`: String
    public var `id`: String
    public var `seq`: UInt64
    public var `createdAt`: String
    public var `senderId`: String
    public var `content`: Content
    public var `read`: Bool
    public var `recall`: Bool
    public var `status`: UInt32
    public var `cachedAt`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`topicId`: String, `id`: String, `seq`: UInt64, `createdAt`: String, `senderId`: String, `content`: Content, `read`: Bool, `recall`: Bool, `status`: UInt32, `cachedAt`: String) {
        self.`topicId` = `topicId`
        self.`id` = `id`
        self.`seq` = `seq`
        self.`createdAt` = `createdAt`
        self.`senderId` = `senderId`
        self.`content` = `content`
        self.`read` = `read`
        self.`recall` = `recall`
        self.`status` = `status`
        self.`cachedAt` = `cachedAt`
    }
}


extension ChatLog: Equatable, Hashable {
    public static func ==(lhs: ChatLog, rhs: ChatLog) -> Bool {
        if lhs.`topicId` != rhs.`topicId` {
            return false
        }
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`seq` != rhs.`seq` {
            return false
        }
        if lhs.`createdAt` != rhs.`createdAt` {
            return false
        }
        if lhs.`senderId` != rhs.`senderId` {
            return false
        }
        if lhs.`content` != rhs.`content` {
            return false
        }
        if lhs.`read` != rhs.`read` {
            return false
        }
        if lhs.`recall` != rhs.`recall` {
            return false
        }
        if lhs.`status` != rhs.`status` {
            return false
        }
        if lhs.`cachedAt` != rhs.`cachedAt` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`topicId`)
        hasher.combine(`id`)
        hasher.combine(`seq`)
        hasher.combine(`createdAt`)
        hasher.combine(`senderId`)
        hasher.combine(`content`)
        hasher.combine(`read`)
        hasher.combine(`recall`)
        hasher.combine(`status`)
        hasher.combine(`cachedAt`)
    }
}


public struct FfiConverterTypeChatLog: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChatLog {
        return try ChatLog(
            `topicId`: FfiConverterString.read(from: &buf), 
            `id`: FfiConverterString.read(from: &buf), 
            `seq`: FfiConverterUInt64.read(from: &buf), 
            `createdAt`: FfiConverterString.read(from: &buf), 
            `senderId`: FfiConverterString.read(from: &buf), 
            `content`: FfiConverterTypeContent.read(from: &buf), 
            `read`: FfiConverterBool.read(from: &buf), 
            `recall`: FfiConverterBool.read(from: &buf), 
            `status`: FfiConverterUInt32.read(from: &buf), 
            `cachedAt`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: ChatLog, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`topicId`, into: &buf)
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterUInt64.write(value.`seq`, into: &buf)
        FfiConverterString.write(value.`createdAt`, into: &buf)
        FfiConverterString.write(value.`senderId`, into: &buf)
        FfiConverterTypeContent.write(value.`content`, into: &buf)
        FfiConverterBool.write(value.`read`, into: &buf)
        FfiConverterBool.write(value.`recall`, into: &buf)
        FfiConverterUInt32.write(value.`status`, into: &buf)
        FfiConverterString.write(value.`cachedAt`, into: &buf)
    }
}


public func FfiConverterTypeChatLog_lift(_ buf: RustBuffer) throws -> ChatLog {
    return try FfiConverterTypeChatLog.lift(buf)
}

public func FfiConverterTypeChatLog_lower(_ value: ChatLog) -> RustBuffer {
    return FfiConverterTypeChatLog.lower(value)
}


public struct Content {
    public var `type`: String
    public var `encrypted`: Bool
    public var `checksum`: UInt32
    public var `text`: String
    public var `placeholder`: String
    public var `thumbnail`: String
    public var `duration`: String
    public var `size`: UInt64
    public var `width`: Float
    public var `height`: Float
    public var `mentions`: [String]
    public var `replyId`: String
    public var `createdAt`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`type`: String, `encrypted`: Bool, `checksum`: UInt32, `text`: String, `placeholder`: String, `thumbnail`: String, `duration`: String, `size`: UInt64, `width`: Float, `height`: Float, `mentions`: [String], `replyId`: String, `createdAt`: String) {
        self.`type` = `type`
        self.`encrypted` = `encrypted`
        self.`checksum` = `checksum`
        self.`text` = `text`
        self.`placeholder` = `placeholder`
        self.`thumbnail` = `thumbnail`
        self.`duration` = `duration`
        self.`size` = `size`
        self.`width` = `width`
        self.`height` = `height`
        self.`mentions` = `mentions`
        self.`replyId` = `replyId`
        self.`createdAt` = `createdAt`
    }
}


extension Content: Equatable, Hashable {
    public static func ==(lhs: Content, rhs: Content) -> Bool {
        if lhs.`type` != rhs.`type` {
            return false
        }
        if lhs.`encrypted` != rhs.`encrypted` {
            return false
        }
        if lhs.`checksum` != rhs.`checksum` {
            return false
        }
        if lhs.`text` != rhs.`text` {
            return false
        }
        if lhs.`placeholder` != rhs.`placeholder` {
            return false
        }
        if lhs.`thumbnail` != rhs.`thumbnail` {
            return false
        }
        if lhs.`duration` != rhs.`duration` {
            return false
        }
        if lhs.`size` != rhs.`size` {
            return false
        }
        if lhs.`width` != rhs.`width` {
            return false
        }
        if lhs.`height` != rhs.`height` {
            return false
        }
        if lhs.`mentions` != rhs.`mentions` {
            return false
        }
        if lhs.`replyId` != rhs.`replyId` {
            return false
        }
        if lhs.`createdAt` != rhs.`createdAt` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`type`)
        hasher.combine(`encrypted`)
        hasher.combine(`checksum`)
        hasher.combine(`text`)
        hasher.combine(`placeholder`)
        hasher.combine(`thumbnail`)
        hasher.combine(`duration`)
        hasher.combine(`size`)
        hasher.combine(`width`)
        hasher.combine(`height`)
        hasher.combine(`mentions`)
        hasher.combine(`replyId`)
        hasher.combine(`createdAt`)
    }
}


public struct FfiConverterTypeContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Content {
        return try Content(
            `type`: FfiConverterString.read(from: &buf), 
            `encrypted`: FfiConverterBool.read(from: &buf), 
            `checksum`: FfiConverterUInt32.read(from: &buf), 
            `text`: FfiConverterString.read(from: &buf), 
            `placeholder`: FfiConverterString.read(from: &buf), 
            `thumbnail`: FfiConverterString.read(from: &buf), 
            `duration`: FfiConverterString.read(from: &buf), 
            `size`: FfiConverterUInt64.read(from: &buf), 
            `width`: FfiConverterFloat.read(from: &buf), 
            `height`: FfiConverterFloat.read(from: &buf), 
            `mentions`: FfiConverterSequenceString.read(from: &buf), 
            `replyId`: FfiConverterString.read(from: &buf), 
            `createdAt`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Content, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`type`, into: &buf)
        FfiConverterBool.write(value.`encrypted`, into: &buf)
        FfiConverterUInt32.write(value.`checksum`, into: &buf)
        FfiConverterString.write(value.`text`, into: &buf)
        FfiConverterString.write(value.`placeholder`, into: &buf)
        FfiConverterString.write(value.`thumbnail`, into: &buf)
        FfiConverterString.write(value.`duration`, into: &buf)
        FfiConverterUInt64.write(value.`size`, into: &buf)
        FfiConverterFloat.write(value.`width`, into: &buf)
        FfiConverterFloat.write(value.`height`, into: &buf)
        FfiConverterSequenceString.write(value.`mentions`, into: &buf)
        FfiConverterString.write(value.`replyId`, into: &buf)
        FfiConverterString.write(value.`createdAt`, into: &buf)
    }
}


public func FfiConverterTypeContent_lift(_ buf: RustBuffer) throws -> Content {
    return try FfiConverterTypeContent.lift(buf)
}

public func FfiConverterTypeContent_lower(_ value: Content) -> RustBuffer {
    return FfiConverterTypeContent.lower(value)
}


public struct Conversation {
    public var `ownerId`: String
    public var `topicId`: String
    public var `lastSeq`: UInt64
    public var `multiple`: Bool
    public var `attendee`: String
    public var `name`: String
    public var `icon`: String
    public var `sticky`: Bool
    public var `mute`: Bool
    public var `unread`: UInt32
    public var `lastSenderId`: String
    public var `lastMessage`: Content?
    public var `lastMessageAt`: String
    public var `cachedAt`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`ownerId`: String, `topicId`: String, `lastSeq`: UInt64, `multiple`: Bool, `attendee`: String, `name`: String, `icon`: String, `sticky`: Bool, `mute`: Bool, `unread`: UInt32, `lastSenderId`: String, `lastMessage`: Content?, `lastMessageAt`: String, `cachedAt`: String) {
        self.`ownerId` = `ownerId`
        self.`topicId` = `topicId`
        self.`lastSeq` = `lastSeq`
        self.`multiple` = `multiple`
        self.`attendee` = `attendee`
        self.`name` = `name`
        self.`icon` = `icon`
        self.`sticky` = `sticky`
        self.`mute` = `mute`
        self.`unread` = `unread`
        self.`lastSenderId` = `lastSenderId`
        self.`lastMessage` = `lastMessage`
        self.`lastMessageAt` = `lastMessageAt`
        self.`cachedAt` = `cachedAt`
    }
}


extension Conversation: Equatable, Hashable {
    public static func ==(lhs: Conversation, rhs: Conversation) -> Bool {
        if lhs.`ownerId` != rhs.`ownerId` {
            return false
        }
        if lhs.`topicId` != rhs.`topicId` {
            return false
        }
        if lhs.`lastSeq` != rhs.`lastSeq` {
            return false
        }
        if lhs.`multiple` != rhs.`multiple` {
            return false
        }
        if lhs.`attendee` != rhs.`attendee` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`icon` != rhs.`icon` {
            return false
        }
        if lhs.`sticky` != rhs.`sticky` {
            return false
        }
        if lhs.`mute` != rhs.`mute` {
            return false
        }
        if lhs.`unread` != rhs.`unread` {
            return false
        }
        if lhs.`lastSenderId` != rhs.`lastSenderId` {
            return false
        }
        if lhs.`lastMessage` != rhs.`lastMessage` {
            return false
        }
        if lhs.`lastMessageAt` != rhs.`lastMessageAt` {
            return false
        }
        if lhs.`cachedAt` != rhs.`cachedAt` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`ownerId`)
        hasher.combine(`topicId`)
        hasher.combine(`lastSeq`)
        hasher.combine(`multiple`)
        hasher.combine(`attendee`)
        hasher.combine(`name`)
        hasher.combine(`icon`)
        hasher.combine(`sticky`)
        hasher.combine(`mute`)
        hasher.combine(`unread`)
        hasher.combine(`lastSenderId`)
        hasher.combine(`lastMessage`)
        hasher.combine(`lastMessageAt`)
        hasher.combine(`cachedAt`)
    }
}


public struct FfiConverterTypeConversation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Conversation {
        return try Conversation(
            `ownerId`: FfiConverterString.read(from: &buf), 
            `topicId`: FfiConverterString.read(from: &buf), 
            `lastSeq`: FfiConverterUInt64.read(from: &buf), 
            `multiple`: FfiConverterBool.read(from: &buf), 
            `attendee`: FfiConverterString.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `icon`: FfiConverterString.read(from: &buf), 
            `sticky`: FfiConverterBool.read(from: &buf), 
            `mute`: FfiConverterBool.read(from: &buf), 
            `unread`: FfiConverterUInt32.read(from: &buf), 
            `lastSenderId`: FfiConverterString.read(from: &buf), 
            `lastMessage`: FfiConverterOptionTypeContent.read(from: &buf), 
            `lastMessageAt`: FfiConverterString.read(from: &buf), 
            `cachedAt`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Conversation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`ownerId`, into: &buf)
        FfiConverterString.write(value.`topicId`, into: &buf)
        FfiConverterUInt64.write(value.`lastSeq`, into: &buf)
        FfiConverterBool.write(value.`multiple`, into: &buf)
        FfiConverterString.write(value.`attendee`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`icon`, into: &buf)
        FfiConverterBool.write(value.`sticky`, into: &buf)
        FfiConverterBool.write(value.`mute`, into: &buf)
        FfiConverterUInt32.write(value.`unread`, into: &buf)
        FfiConverterString.write(value.`lastSenderId`, into: &buf)
        FfiConverterOptionTypeContent.write(value.`lastMessage`, into: &buf)
        FfiConverterString.write(value.`lastMessageAt`, into: &buf)
        FfiConverterString.write(value.`cachedAt`, into: &buf)
    }
}


public func FfiConverterTypeConversation_lift(_ buf: RustBuffer) throws -> Conversation {
    return try FfiConverterTypeConversation.lift(buf)
}

public func FfiConverterTypeConversation_lower(_ value: Conversation) -> RustBuffer {
    return FfiConverterTypeConversation.lower(value)
}


public struct ListChatLogResult {
    public var `hasMore`: Bool
    public var `updatedAt`: String
    public var `lastSeq`: UInt64
    public var `items`: [ChatLog]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`hasMore`: Bool, `updatedAt`: String, `lastSeq`: UInt64, `items`: [ChatLog]) {
        self.`hasMore` = `hasMore`
        self.`updatedAt` = `updatedAt`
        self.`lastSeq` = `lastSeq`
        self.`items` = `items`
    }
}


extension ListChatLogResult: Equatable, Hashable {
    public static func ==(lhs: ListChatLogResult, rhs: ListChatLogResult) -> Bool {
        if lhs.`hasMore` != rhs.`hasMore` {
            return false
        }
        if lhs.`updatedAt` != rhs.`updatedAt` {
            return false
        }
        if lhs.`lastSeq` != rhs.`lastSeq` {
            return false
        }
        if lhs.`items` != rhs.`items` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`hasMore`)
        hasher.combine(`updatedAt`)
        hasher.combine(`lastSeq`)
        hasher.combine(`items`)
    }
}


public struct FfiConverterTypeListChatLogResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListChatLogResult {
        return try ListChatLogResult(
            `hasMore`: FfiConverterBool.read(from: &buf), 
            `updatedAt`: FfiConverterString.read(from: &buf), 
            `lastSeq`: FfiConverterUInt64.read(from: &buf), 
            `items`: FfiConverterSequenceTypeChatLog.read(from: &buf)
        )
    }

    public static func write(_ value: ListChatLogResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`hasMore`, into: &buf)
        FfiConverterString.write(value.`updatedAt`, into: &buf)
        FfiConverterUInt64.write(value.`lastSeq`, into: &buf)
        FfiConverterSequenceTypeChatLog.write(value.`items`, into: &buf)
    }
}


public func FfiConverterTypeListChatLogResult_lift(_ buf: RustBuffer) throws -> ListChatLogResult {
    return try FfiConverterTypeListChatLogResult.lift(buf)
}

public func FfiConverterTypeListChatLogResult_lower(_ value: ListChatLogResult) -> RustBuffer {
    return FfiConverterTypeListChatLogResult.lower(value)
}


public struct ListConversationResult {
    public var `hasMore`: Bool
    public var `updatedAt`: String
    public var `items`: [Conversation]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`hasMore`: Bool, `updatedAt`: String, `items`: [Conversation]) {
        self.`hasMore` = `hasMore`
        self.`updatedAt` = `updatedAt`
        self.`items` = `items`
    }
}


extension ListConversationResult: Equatable, Hashable {
    public static func ==(lhs: ListConversationResult, rhs: ListConversationResult) -> Bool {
        if lhs.`hasMore` != rhs.`hasMore` {
            return false
        }
        if lhs.`updatedAt` != rhs.`updatedAt` {
            return false
        }
        if lhs.`items` != rhs.`items` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`hasMore`)
        hasher.combine(`updatedAt`)
        hasher.combine(`items`)
    }
}


public struct FfiConverterTypeListConversationResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListConversationResult {
        return try ListConversationResult(
            `hasMore`: FfiConverterBool.read(from: &buf), 
            `updatedAt`: FfiConverterString.read(from: &buf), 
            `items`: FfiConverterSequenceTypeConversation.read(from: &buf)
        )
    }

    public static func write(_ value: ListConversationResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`hasMore`, into: &buf)
        FfiConverterString.write(value.`updatedAt`, into: &buf)
        FfiConverterSequenceTypeConversation.write(value.`items`, into: &buf)
    }
}


public func FfiConverterTypeListConversationResult_lift(_ buf: RustBuffer) throws -> ListConversationResult {
    return try FfiConverterTypeListConversationResult.lift(buf)
}

public func FfiConverterTypeListConversationResult_lower(_ value: ListConversationResult) -> RustBuffer {
    return FfiConverterTypeListConversationResult.lower(value)
}


public struct ListUserResult {
    public var `hasMore`: Bool
    public var `updatedAt`: String
    public var `items`: [User]
    public var `removed`: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`hasMore`: Bool, `updatedAt`: String, `items`: [User], `removed`: [String]) {
        self.`hasMore` = `hasMore`
        self.`updatedAt` = `updatedAt`
        self.`items` = `items`
        self.`removed` = `removed`
    }
}


extension ListUserResult: Equatable, Hashable {
    public static func ==(lhs: ListUserResult, rhs: ListUserResult) -> Bool {
        if lhs.`hasMore` != rhs.`hasMore` {
            return false
        }
        if lhs.`updatedAt` != rhs.`updatedAt` {
            return false
        }
        if lhs.`items` != rhs.`items` {
            return false
        }
        if lhs.`removed` != rhs.`removed` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`hasMore`)
        hasher.combine(`updatedAt`)
        hasher.combine(`items`)
        hasher.combine(`removed`)
    }
}


public struct FfiConverterTypeListUserResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListUserResult {
        return try ListUserResult(
            `hasMore`: FfiConverterBool.read(from: &buf), 
            `updatedAt`: FfiConverterString.read(from: &buf), 
            `items`: FfiConverterSequenceTypeUser.read(from: &buf), 
            `removed`: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: ListUserResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.`hasMore`, into: &buf)
        FfiConverterString.write(value.`updatedAt`, into: &buf)
        FfiConverterSequenceTypeUser.write(value.`items`, into: &buf)
        FfiConverterSequenceString.write(value.`removed`, into: &buf)
    }
}


public func FfiConverterTypeListUserResult_lift(_ buf: RustBuffer) throws -> ListUserResult {
    return try FfiConverterTypeListUserResult.lift(buf)
}

public func FfiConverterTypeListUserResult_lower(_ value: ListUserResult) -> RustBuffer {
    return FfiConverterTypeListUserResult.lower(value)
}


public struct Topic {
    public var `id`: String
    public var `name`: String
    public var `icon`: String
    public var `remark`: String
    public var `ownerId`: String
    public var `attendeeId`: String
    public var `admins`: [String]
    public var `members`: UInt32
    public var `lastSeq`: UInt64
    public var `multiple`: Bool
    public var `private`: Bool
    public var `createdAt`: String
    public var `updatedAt`: String
    public var `notice`: TopicNotice?
    public var `silent`: Bool
    public var `unread`: UInt32
    public var `cachedAt`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`id`: String, `name`: String, `icon`: String, `remark`: String, `ownerId`: String, `attendeeId`: String, `admins`: [String], `members`: UInt32, `lastSeq`: UInt64, `multiple`: Bool, `private`: Bool, `createdAt`: String, `updatedAt`: String, `notice`: TopicNotice?, `silent`: Bool, `unread`: UInt32, `cachedAt`: String) {
        self.`id` = `id`
        self.`name` = `name`
        self.`icon` = `icon`
        self.`remark` = `remark`
        self.`ownerId` = `ownerId`
        self.`attendeeId` = `attendeeId`
        self.`admins` = `admins`
        self.`members` = `members`
        self.`lastSeq` = `lastSeq`
        self.`multiple` = `multiple`
        self.`private` = `private`
        self.`createdAt` = `createdAt`
        self.`updatedAt` = `updatedAt`
        self.`notice` = `notice`
        self.`silent` = `silent`
        self.`unread` = `unread`
        self.`cachedAt` = `cachedAt`
    }
}


extension Topic: Equatable, Hashable {
    public static func ==(lhs: Topic, rhs: Topic) -> Bool {
        if lhs.`id` != rhs.`id` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`icon` != rhs.`icon` {
            return false
        }
        if lhs.`remark` != rhs.`remark` {
            return false
        }
        if lhs.`ownerId` != rhs.`ownerId` {
            return false
        }
        if lhs.`attendeeId` != rhs.`attendeeId` {
            return false
        }
        if lhs.`admins` != rhs.`admins` {
            return false
        }
        if lhs.`members` != rhs.`members` {
            return false
        }
        if lhs.`lastSeq` != rhs.`lastSeq` {
            return false
        }
        if lhs.`multiple` != rhs.`multiple` {
            return false
        }
        if lhs.`private` != rhs.`private` {
            return false
        }
        if lhs.`createdAt` != rhs.`createdAt` {
            return false
        }
        if lhs.`updatedAt` != rhs.`updatedAt` {
            return false
        }
        if lhs.`notice` != rhs.`notice` {
            return false
        }
        if lhs.`silent` != rhs.`silent` {
            return false
        }
        if lhs.`unread` != rhs.`unread` {
            return false
        }
        if lhs.`cachedAt` != rhs.`cachedAt` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`id`)
        hasher.combine(`name`)
        hasher.combine(`icon`)
        hasher.combine(`remark`)
        hasher.combine(`ownerId`)
        hasher.combine(`attendeeId`)
        hasher.combine(`admins`)
        hasher.combine(`members`)
        hasher.combine(`lastSeq`)
        hasher.combine(`multiple`)
        hasher.combine(`private`)
        hasher.combine(`createdAt`)
        hasher.combine(`updatedAt`)
        hasher.combine(`notice`)
        hasher.combine(`silent`)
        hasher.combine(`unread`)
        hasher.combine(`cachedAt`)
    }
}


public struct FfiConverterTypeTopic: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Topic {
        return try Topic(
            `id`: FfiConverterString.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `icon`: FfiConverterString.read(from: &buf), 
            `remark`: FfiConverterString.read(from: &buf), 
            `ownerId`: FfiConverterString.read(from: &buf), 
            `attendeeId`: FfiConverterString.read(from: &buf), 
            `admins`: FfiConverterSequenceString.read(from: &buf), 
            `members`: FfiConverterUInt32.read(from: &buf), 
            `lastSeq`: FfiConverterUInt64.read(from: &buf), 
            `multiple`: FfiConverterBool.read(from: &buf), 
            `private`: FfiConverterBool.read(from: &buf), 
            `createdAt`: FfiConverterString.read(from: &buf), 
            `updatedAt`: FfiConverterString.read(from: &buf), 
            `notice`: FfiConverterOptionTypeTopicNotice.read(from: &buf), 
            `silent`: FfiConverterBool.read(from: &buf), 
            `unread`: FfiConverterUInt32.read(from: &buf), 
            `cachedAt`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Topic, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`id`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`icon`, into: &buf)
        FfiConverterString.write(value.`remark`, into: &buf)
        FfiConverterString.write(value.`ownerId`, into: &buf)
        FfiConverterString.write(value.`attendeeId`, into: &buf)
        FfiConverterSequenceString.write(value.`admins`, into: &buf)
        FfiConverterUInt32.write(value.`members`, into: &buf)
        FfiConverterUInt64.write(value.`lastSeq`, into: &buf)
        FfiConverterBool.write(value.`multiple`, into: &buf)
        FfiConverterBool.write(value.`private`, into: &buf)
        FfiConverterString.write(value.`createdAt`, into: &buf)
        FfiConverterString.write(value.`updatedAt`, into: &buf)
        FfiConverterOptionTypeTopicNotice.write(value.`notice`, into: &buf)
        FfiConverterBool.write(value.`silent`, into: &buf)
        FfiConverterUInt32.write(value.`unread`, into: &buf)
        FfiConverterString.write(value.`cachedAt`, into: &buf)
    }
}


public func FfiConverterTypeTopic_lift(_ buf: RustBuffer) throws -> Topic {
    return try FfiConverterTypeTopic.lift(buf)
}

public func FfiConverterTypeTopic_lower(_ value: Topic) -> RustBuffer {
    return FfiConverterTypeTopic.lower(value)
}


public struct TopicKnock {
    public var `createdAt`: String
    public var `updatedAt`: String
    public var `topicId`: String
    public var `userId`: String
    public var `message`: String
    public var `source`: String
    public var `status`: String
    public var `adminId`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`createdAt`: String, `updatedAt`: String, `topicId`: String, `userId`: String, `message`: String, `source`: String, `status`: String, `adminId`: String) {
        self.`createdAt` = `createdAt`
        self.`updatedAt` = `updatedAt`
        self.`topicId` = `topicId`
        self.`userId` = `userId`
        self.`message` = `message`
        self.`source` = `source`
        self.`status` = `status`
        self.`adminId` = `adminId`
    }
}


extension TopicKnock: Equatable, Hashable {
    public static func ==(lhs: TopicKnock, rhs: TopicKnock) -> Bool {
        if lhs.`createdAt` != rhs.`createdAt` {
            return false
        }
        if lhs.`updatedAt` != rhs.`updatedAt` {
            return false
        }
        if lhs.`topicId` != rhs.`topicId` {
            return false
        }
        if lhs.`userId` != rhs.`userId` {
            return false
        }
        if lhs.`message` != rhs.`message` {
            return false
        }
        if lhs.`source` != rhs.`source` {
            return false
        }
        if lhs.`status` != rhs.`status` {
            return false
        }
        if lhs.`adminId` != rhs.`adminId` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`createdAt`)
        hasher.combine(`updatedAt`)
        hasher.combine(`topicId`)
        hasher.combine(`userId`)
        hasher.combine(`message`)
        hasher.combine(`source`)
        hasher.combine(`status`)
        hasher.combine(`adminId`)
    }
}


public struct FfiConverterTypeTopicKnock: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TopicKnock {
        return try TopicKnock(
            `createdAt`: FfiConverterString.read(from: &buf), 
            `updatedAt`: FfiConverterString.read(from: &buf), 
            `topicId`: FfiConverterString.read(from: &buf), 
            `userId`: FfiConverterString.read(from: &buf), 
            `message`: FfiConverterString.read(from: &buf), 
            `source`: FfiConverterString.read(from: &buf), 
            `status`: FfiConverterString.read(from: &buf), 
            `adminId`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TopicKnock, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`createdAt`, into: &buf)
        FfiConverterString.write(value.`updatedAt`, into: &buf)
        FfiConverterString.write(value.`topicId`, into: &buf)
        FfiConverterString.write(value.`userId`, into: &buf)
        FfiConverterString.write(value.`message`, into: &buf)
        FfiConverterString.write(value.`source`, into: &buf)
        FfiConverterString.write(value.`status`, into: &buf)
        FfiConverterString.write(value.`adminId`, into: &buf)
    }
}


public func FfiConverterTypeTopicKnock_lift(_ buf: RustBuffer) throws -> TopicKnock {
    return try FfiConverterTypeTopicKnock.lift(buf)
}

public func FfiConverterTypeTopicKnock_lower(_ value: TopicKnock) -> RustBuffer {
    return FfiConverterTypeTopicKnock.lower(value)
}


public struct TopicMember {
    public var `topicId`: String
    public var `userId`: String
    public var `isOwner`: Bool
    public var `isAdmin`: Bool
    public var `remark`: String
    public var `silent`: Bool
    public var `joinedAt`: String
    public var `cachedAt`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`topicId`: String, `userId`: String, `isOwner`: Bool, `isAdmin`: Bool, `remark`: String, `silent`: Bool, `joinedAt`: String, `cachedAt`: String) {
        self.`topicId` = `topicId`
        self.`userId` = `userId`
        self.`isOwner` = `isOwner`
        self.`isAdmin` = `isAdmin`
        self.`remark` = `remark`
        self.`silent` = `silent`
        self.`joinedAt` = `joinedAt`
        self.`cachedAt` = `cachedAt`
    }
}


extension TopicMember: Equatable, Hashable {
    public static func ==(lhs: TopicMember, rhs: TopicMember) -> Bool {
        if lhs.`topicId` != rhs.`topicId` {
            return false
        }
        if lhs.`userId` != rhs.`userId` {
            return false
        }
        if lhs.`isOwner` != rhs.`isOwner` {
            return false
        }
        if lhs.`isAdmin` != rhs.`isAdmin` {
            return false
        }
        if lhs.`remark` != rhs.`remark` {
            return false
        }
        if lhs.`silent` != rhs.`silent` {
            return false
        }
        if lhs.`joinedAt` != rhs.`joinedAt` {
            return false
        }
        if lhs.`cachedAt` != rhs.`cachedAt` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`topicId`)
        hasher.combine(`userId`)
        hasher.combine(`isOwner`)
        hasher.combine(`isAdmin`)
        hasher.combine(`remark`)
        hasher.combine(`silent`)
        hasher.combine(`joinedAt`)
        hasher.combine(`cachedAt`)
    }
}


public struct FfiConverterTypeTopicMember: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TopicMember {
        return try TopicMember(
            `topicId`: FfiConverterString.read(from: &buf), 
            `userId`: FfiConverterString.read(from: &buf), 
            `isOwner`: FfiConverterBool.read(from: &buf), 
            `isAdmin`: FfiConverterBool.read(from: &buf), 
            `remark`: FfiConverterString.read(from: &buf), 
            `silent`: FfiConverterBool.read(from: &buf), 
            `joinedAt`: FfiConverterString.read(from: &buf), 
            `cachedAt`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TopicMember, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`topicId`, into: &buf)
        FfiConverterString.write(value.`userId`, into: &buf)
        FfiConverterBool.write(value.`isOwner`, into: &buf)
        FfiConverterBool.write(value.`isAdmin`, into: &buf)
        FfiConverterString.write(value.`remark`, into: &buf)
        FfiConverterBool.write(value.`silent`, into: &buf)
        FfiConverterString.write(value.`joinedAt`, into: &buf)
        FfiConverterString.write(value.`cachedAt`, into: &buf)
    }
}


public func FfiConverterTypeTopicMember_lift(_ buf: RustBuffer) throws -> TopicMember {
    return try FfiConverterTypeTopicMember.lift(buf)
}

public func FfiConverterTypeTopicMember_lower(_ value: TopicMember) -> RustBuffer {
    return FfiConverterTypeTopicMember.lower(value)
}


public struct TopicNotice {
    public var `text`: String
    public var `publisher`: String
    public var `updatedAt`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`text`: String, `publisher`: String, `updatedAt`: String) {
        self.`text` = `text`
        self.`publisher` = `publisher`
        self.`updatedAt` = `updatedAt`
    }
}


extension TopicNotice: Equatable, Hashable {
    public static func ==(lhs: TopicNotice, rhs: TopicNotice) -> Bool {
        if lhs.`text` != rhs.`text` {
            return false
        }
        if lhs.`publisher` != rhs.`publisher` {
            return false
        }
        if lhs.`updatedAt` != rhs.`updatedAt` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`text`)
        hasher.combine(`publisher`)
        hasher.combine(`updatedAt`)
    }
}


public struct FfiConverterTypeTopicNotice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TopicNotice {
        return try TopicNotice(
            `text`: FfiConverterString.read(from: &buf), 
            `publisher`: FfiConverterString.read(from: &buf), 
            `updatedAt`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TopicNotice, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`text`, into: &buf)
        FfiConverterString.write(value.`publisher`, into: &buf)
        FfiConverterString.write(value.`updatedAt`, into: &buf)
    }
}


public func FfiConverterTypeTopicNotice_lift(_ buf: RustBuffer) throws -> TopicNotice {
    return try FfiConverterTypeTopicNotice.lift(buf)
}

public func FfiConverterTypeTopicNotice_lower(_ value: TopicNotice) -> RustBuffer {
    return FfiConverterTypeTopicNotice.lower(value)
}


public struct User {
    public var `userId`: String
    public var `name`: String
    public var `avatar`: String
    public var `publicKey`: String
    public var `remark`: String
    public var `isContact`: Bool
    public var `isStar`: Bool
    public var `isBlocked`: Bool
    public var `locale`: String
    public var `city`: String
    public var `country`: String
    public var `source`: String
    public var `gender`: String
    public var `createdAt`: String
    public var `cachedAt`: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(`userId`: String, `name`: String, `avatar`: String, `publicKey`: String, `remark`: String, `isContact`: Bool, `isStar`: Bool, `isBlocked`: Bool, `locale`: String, `city`: String, `country`: String, `source`: String, `gender`: String, `createdAt`: String, `cachedAt`: String) {
        self.`userId` = `userId`
        self.`name` = `name`
        self.`avatar` = `avatar`
        self.`publicKey` = `publicKey`
        self.`remark` = `remark`
        self.`isContact` = `isContact`
        self.`isStar` = `isStar`
        self.`isBlocked` = `isBlocked`
        self.`locale` = `locale`
        self.`city` = `city`
        self.`country` = `country`
        self.`source` = `source`
        self.`gender` = `gender`
        self.`createdAt` = `createdAt`
        self.`cachedAt` = `cachedAt`
    }
}


extension User: Equatable, Hashable {
    public static func ==(lhs: User, rhs: User) -> Bool {
        if lhs.`userId` != rhs.`userId` {
            return false
        }
        if lhs.`name` != rhs.`name` {
            return false
        }
        if lhs.`avatar` != rhs.`avatar` {
            return false
        }
        if lhs.`publicKey` != rhs.`publicKey` {
            return false
        }
        if lhs.`remark` != rhs.`remark` {
            return false
        }
        if lhs.`isContact` != rhs.`isContact` {
            return false
        }
        if lhs.`isStar` != rhs.`isStar` {
            return false
        }
        if lhs.`isBlocked` != rhs.`isBlocked` {
            return false
        }
        if lhs.`locale` != rhs.`locale` {
            return false
        }
        if lhs.`city` != rhs.`city` {
            return false
        }
        if lhs.`country` != rhs.`country` {
            return false
        }
        if lhs.`source` != rhs.`source` {
            return false
        }
        if lhs.`gender` != rhs.`gender` {
            return false
        }
        if lhs.`createdAt` != rhs.`createdAt` {
            return false
        }
        if lhs.`cachedAt` != rhs.`cachedAt` {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(`userId`)
        hasher.combine(`name`)
        hasher.combine(`avatar`)
        hasher.combine(`publicKey`)
        hasher.combine(`remark`)
        hasher.combine(`isContact`)
        hasher.combine(`isStar`)
        hasher.combine(`isBlocked`)
        hasher.combine(`locale`)
        hasher.combine(`city`)
        hasher.combine(`country`)
        hasher.combine(`source`)
        hasher.combine(`gender`)
        hasher.combine(`createdAt`)
        hasher.combine(`cachedAt`)
    }
}


public struct FfiConverterTypeUser: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> User {
        return try User(
            `userId`: FfiConverterString.read(from: &buf), 
            `name`: FfiConverterString.read(from: &buf), 
            `avatar`: FfiConverterString.read(from: &buf), 
            `publicKey`: FfiConverterString.read(from: &buf), 
            `remark`: FfiConverterString.read(from: &buf), 
            `isContact`: FfiConverterBool.read(from: &buf), 
            `isStar`: FfiConverterBool.read(from: &buf), 
            `isBlocked`: FfiConverterBool.read(from: &buf), 
            `locale`: FfiConverterString.read(from: &buf), 
            `city`: FfiConverterString.read(from: &buf), 
            `country`: FfiConverterString.read(from: &buf), 
            `source`: FfiConverterString.read(from: &buf), 
            `gender`: FfiConverterString.read(from: &buf), 
            `createdAt`: FfiConverterString.read(from: &buf), 
            `cachedAt`: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: User, into buf: inout [UInt8]) {
        FfiConverterString.write(value.`userId`, into: &buf)
        FfiConverterString.write(value.`name`, into: &buf)
        FfiConverterString.write(value.`avatar`, into: &buf)
        FfiConverterString.write(value.`publicKey`, into: &buf)
        FfiConverterString.write(value.`remark`, into: &buf)
        FfiConverterBool.write(value.`isContact`, into: &buf)
        FfiConverterBool.write(value.`isStar`, into: &buf)
        FfiConverterBool.write(value.`isBlocked`, into: &buf)
        FfiConverterString.write(value.`locale`, into: &buf)
        FfiConverterString.write(value.`city`, into: &buf)
        FfiConverterString.write(value.`country`, into: &buf)
        FfiConverterString.write(value.`source`, into: &buf)
        FfiConverterString.write(value.`gender`, into: &buf)
        FfiConverterString.write(value.`createdAt`, into: &buf)
        FfiConverterString.write(value.`cachedAt`, into: &buf)
    }
}


public func FfiConverterTypeUser_lift(_ buf: RustBuffer) throws -> User {
    return try FfiConverterTypeUser.lift(buf)
}

public func FfiConverterTypeUser_lower(_ value: User) -> RustBuffer {
    return FfiConverterTypeUser.lower(value)
}

public enum ClientError {

    
    
    // Simple error enums only carry a message
    case InvalidPassword(message: String)
    
    // Simple error enums only carry a message
    case TokenExpired(message: String)
    
    // Simple error enums only carry a message
    case NetworkBroken(message: String)
    
    // Simple error enums only carry a message
    case TopicNotFound(message: String)
    
    // Simple error enums only carry a message
    case TopicKnockNotFound(message: String)
    
    // Simple error enums only carry a message
    case ChatLogNotFound(message: String)
    
    // Simple error enums only carry a message
    case InvalidContent(message: String)
    
    // Simple error enums only carry a message
    case ConversationNotFound(message: String)
    
    // Simple error enums only carry a message
    case UserNotFound(message: String)
    
    // Simple error enums only carry a message
    case KickOffByOtherClient(message: String)
    
    // Simple error enums only carry a message
    case DbMigrateError(message: String)
    
    // Simple error enums only carry a message
    case DbPoolError(message: String)
    
    // Simple error enums only carry a message
    case DbError(message: String)
    
    // Simple error enums only carry a message
    case StdError(message: String)
    
    // Simple error enums only carry a message
    case WebsocketError(message: String)
    
    // Simple error enums only carry a message
    case HttpError(message: String)
    
    // Simple error enums only carry a message
    case JsonError(message: String)
    
    // Simple error enums only carry a message
    case SendCtrlMessageError(message: String)
    
    // Simple error enums only carry a message
    case UnknownError(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeClientError.lift(error)
    }
}


public struct FfiConverterTypeClientError: FfiConverterRustBuffer {
    typealias SwiftType = ClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidPassword(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .TokenExpired(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .NetworkBroken(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .TopicNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .TopicKnockNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .ChatLogNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .InvalidContent(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .ConversationNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .UserNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .KickOffByOtherClient(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .DbMigrateError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .DbPoolError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .DbError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 14: return .StdError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .WebsocketError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 16: return .HttpError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 17: return .JsonError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 18: return .SendCtrlMessageError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 19: return .UnknownError(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientError, into buf: inout [UInt8]) {
        switch value {

        

        
        case let .InvalidPassword(message):
            writeInt(&buf, Int32(1))
        case let .TokenExpired(message):
            writeInt(&buf, Int32(2))
        case let .NetworkBroken(message):
            writeInt(&buf, Int32(3))
        case let .TopicNotFound(message):
            writeInt(&buf, Int32(4))
        case let .TopicKnockNotFound(message):
            writeInt(&buf, Int32(5))
        case let .ChatLogNotFound(message):
            writeInt(&buf, Int32(6))
        case let .InvalidContent(message):
            writeInt(&buf, Int32(7))
        case let .ConversationNotFound(message):
            writeInt(&buf, Int32(8))
        case let .UserNotFound(message):
            writeInt(&buf, Int32(9))
        case let .KickOffByOtherClient(message):
            writeInt(&buf, Int32(10))
        case let .DbMigrateError(message):
            writeInt(&buf, Int32(11))
        case let .DbPoolError(message):
            writeInt(&buf, Int32(12))
        case let .DbError(message):
            writeInt(&buf, Int32(13))
        case let .StdError(message):
            writeInt(&buf, Int32(14))
        case let .WebsocketError(message):
            writeInt(&buf, Int32(15))
        case let .HttpError(message):
            writeInt(&buf, Int32(16))
        case let .JsonError(message):
            writeInt(&buf, Int32(17))
        case let .SendCtrlMessageError(message):
            writeInt(&buf, Int32(18))
        case let .UnknownError(message):
            writeInt(&buf, Int32(19))

        
        }
    }
}


extension ClientError: Equatable, Hashable {}

extension ClientError: Error { }

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum NetworkState {
    
    case `connecting`
    case `connected`
    case `disconnected`
}

public struct FfiConverterTypeNetworkState: FfiConverterRustBuffer {
    typealias SwiftType = NetworkState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NetworkState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`connecting`
        
        case 2: return .`connected`
        
        case 3: return .`disconnected`
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NetworkState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`connecting`:
            writeInt(&buf, Int32(1))
        
        
        case .`connected`:
            writeInt(&buf, Int32(2))
        
        
        case .`disconnected`:
            writeInt(&buf, Int32(3))
        
        }
    }
}


public func FfiConverterTypeNetworkState_lift(_ buf: RustBuffer) throws -> NetworkState {
    return try FfiConverterTypeNetworkState.lift(buf)
}

public func FfiConverterTypeNetworkState_lower(_ value: NetworkState) -> RustBuffer {
    return FfiConverterTypeNetworkState.lower(value)
}


extension NetworkState: Equatable, Hashable {}



fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for Callback Callback Interface

public protocol Callback : AnyObject {
    func `onConnected`() 
    func `onConnecting`() 
    func `onNetBroken`(`reason`: String) 
    func `onKickoffByOtherClient`(`reason`: String) 
    func `onSendMessageFail`(`topicId`: String, `chatId`: String, `code`: UInt32) 
    func `onTopicKnock`(`topicId`: String, `message`: String, `source`: String) 
    func `onTopicKnockReject`(`userId`: String, `message`: String) 
    func `onTopicJoin`(`topicId`: String) 
    func `onRead`(`topicId`: String) 
    func `onRecall`(`topicId`: String, `chatId`: String) 
    func `onTyping`(`topicId`: String, `userId`: String) 
    func `onTopicMessage`(`topicId`: String, `message`: ChatLog) 
    func `onTopicNoticeUpdated`(`topicId`: String, `notice`: TopicNotice) 
    func `onTopicMemberUpdated`(`topicId`: String, `member`: User, `isAdd`: Bool) 
    func `onConversationUpdated`(`conversations`: [Conversation]) 
    func `onConversationRemoved`(`topicId`: String) 
    func `onTopicKickoff`(`topicId`: String, `adminId`: String, `userId`: String) 
    func `onTopicDismissed`(`topicId`: String, `userId`: String) 
    func `onTopicSilent`(`topicId`: String, `duration`: String) 
    func `onTopicSilentMember`(`topicId`: String, `userId`: String, `duration`: String) 
    func `onDownloadProgress`(`fileUrl`: String, `received`: UInt32, `total`: UInt32, `key`: String) 
    func `onDownloadDone`(`fileUrl`: String, `localFileName`: String, `size`: UInt32, `key`: String) 
    func `onDownloadCancel`(`fileUrl`: String, `localFileName`: String, `reason`: String, `key`: String) 
    func `onUploadProgress`(`localFilePath`: String, `received`: UInt32, `total`: UInt32, `key`: String) 
    func `onUploadDone`(`url`: String, `localFilePath`: String, `size`: UInt32, `key`: String) 
    func `onUploadCancel`(`url`: String, `localFilePath`: String, `reason`: String, `key`: String) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeOnConnected`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onConnected`(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnConnecting`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onConnecting`(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnNetBroken`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onNetBroken`(
                    `reason`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnKickoffByOtherClient`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onKickoffByOtherClient`(
                    `reason`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnSendMessageFail`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onSendMessageFail`(
                    `topicId`:  try FfiConverterString.read(from: &reader), 
                    `chatId`:  try FfiConverterString.read(from: &reader), 
                    `code`:  try FfiConverterUInt32.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnTopicKnock`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onTopicKnock`(
                    `topicId`:  try FfiConverterString.read(from: &reader), 
                    `message`:  try FfiConverterString.read(from: &reader), 
                    `source`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnTopicKnockReject`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onTopicKnockReject`(
                    `userId`:  try FfiConverterString.read(from: &reader), 
                    `message`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnTopicJoin`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onTopicJoin`(
                    `topicId`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnRead`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onRead`(
                    `topicId`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnRecall`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onRecall`(
                    `topicId`:  try FfiConverterString.read(from: &reader), 
                    `chatId`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnTyping`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onTyping`(
                    `topicId`:  try FfiConverterString.read(from: &reader), 
                    `userId`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnTopicMessage`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onTopicMessage`(
                    `topicId`:  try FfiConverterString.read(from: &reader), 
                    `message`:  try FfiConverterTypeChatLog.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnTopicNoticeUpdated`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onTopicNoticeUpdated`(
                    `topicId`:  try FfiConverterString.read(from: &reader), 
                    `notice`:  try FfiConverterTypeTopicNotice.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnTopicMemberUpdated`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onTopicMemberUpdated`(
                    `topicId`:  try FfiConverterString.read(from: &reader), 
                    `member`:  try FfiConverterTypeUser.read(from: &reader), 
                    `isAdd`:  try FfiConverterBool.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnConversationUpdated`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onConversationUpdated`(
                    `conversations`:  try FfiConverterSequenceTypeConversation.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnConversationRemoved`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onConversationRemoved`(
                    `topicId`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnTopicKickoff`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onTopicKickoff`(
                    `topicId`:  try FfiConverterString.read(from: &reader), 
                    `adminId`:  try FfiConverterString.read(from: &reader), 
                    `userId`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnTopicDismissed`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onTopicDismissed`(
                    `topicId`:  try FfiConverterString.read(from: &reader), 
                    `userId`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnTopicSilent`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onTopicSilent`(
                    `topicId`:  try FfiConverterString.read(from: &reader), 
                    `duration`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnTopicSilentMember`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onTopicSilentMember`(
                    `topicId`:  try FfiConverterString.read(from: &reader), 
                    `userId`:  try FfiConverterString.read(from: &reader), 
                    `duration`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnDownloadProgress`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onDownloadProgress`(
                    `fileUrl`:  try FfiConverterString.read(from: &reader), 
                    `received`:  try FfiConverterUInt32.read(from: &reader), 
                    `total`:  try FfiConverterUInt32.read(from: &reader), 
                    `key`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnDownloadDone`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onDownloadDone`(
                    `fileUrl`:  try FfiConverterString.read(from: &reader), 
                    `localFileName`:  try FfiConverterString.read(from: &reader), 
                    `size`:  try FfiConverterUInt32.read(from: &reader), 
                    `key`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnDownloadCancel`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onDownloadCancel`(
                    `fileUrl`:  try FfiConverterString.read(from: &reader), 
                    `localFileName`:  try FfiConverterString.read(from: &reader), 
                    `reason`:  try FfiConverterString.read(from: &reader), 
                    `key`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnUploadProgress`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onUploadProgress`(
                    `localFilePath`:  try FfiConverterString.read(from: &reader), 
                    `received`:  try FfiConverterUInt32.read(from: &reader), 
                    `total`:  try FfiConverterUInt32.read(from: &reader), 
                    `key`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnUploadDone`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onUploadDone`(
                    `url`:  try FfiConverterString.read(from: &reader), 
                    `localFilePath`:  try FfiConverterString.read(from: &reader), 
                    `size`:  try FfiConverterUInt32.read(from: &reader), 
                    `key`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeOnUploadCancel`(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`onUploadCancel`(
                    `url`:  try FfiConverterString.read(from: &reader), 
                    `localFilePath`:  try FfiConverterString.read(from: &reader), 
                    `reason`:  try FfiConverterString.read(from: &reader), 
                    `key`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceCallback.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnConnected`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnConnecting`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 3:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnNetBroken`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 4:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnKickoffByOtherClient`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 5:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnSendMessageFail`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 6:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnTopicKnock`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 7:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnTopicKnockReject`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 8:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnTopicJoin`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 9:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnRead`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 10:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnRecall`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 11:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnTyping`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 12:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnTopicMessage`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 13:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnTopicNoticeUpdated`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 14:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnTopicMemberUpdated`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 15:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnConversationUpdated`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 16:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnConversationRemoved`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 17:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnTopicKickoff`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 18:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnTopicDismissed`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 19:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnTopicSilent`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 20:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnTopicSilentMember`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 21:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnDownloadProgress`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 22:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnDownloadDone`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 23:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnDownloadCancel`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 24:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnUploadProgress`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 25:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnUploadDone`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 26:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeOnUploadCancel`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceCallback {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_client_fn_init_callback_callback(foreignCallbackCallbackInterfaceCallback, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<Callback>()
}

extension FfiConverterCallbackInterfaceCallback : FfiConverter {
    typealias SwiftType = Callback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for Uploader Callback Interface

public protocol Uploader : AnyObject {
    func `upload`(`localFilePath`: String, `key`: String) 
    func `download`(`fileUrl`: String, `saveToLocal`: String, `key`: String) 
    func `cancelDownload`(`fileUrl`: String, `key`: String) 
    func `cancelUpload`(`localFilePath`: String, `key`: String) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceUploader : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func `invokeUpload`(_ swiftCallbackInterface: Uploader, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`upload`(
                    `localFilePath`:  try FfiConverterString.read(from: &reader), 
                    `key`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeDownload`(_ swiftCallbackInterface: Uploader, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`download`(
                    `fileUrl`:  try FfiConverterString.read(from: &reader), 
                    `saveToLocal`:  try FfiConverterString.read(from: &reader), 
                    `key`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeCancelDownload`(_ swiftCallbackInterface: Uploader, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`cancelDownload`(
                    `fileUrl`:  try FfiConverterString.read(from: &reader), 
                    `key`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func `invokeCancelUpload`(_ swiftCallbackInterface: Uploader, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.`cancelUpload`(
                    `localFilePath`:  try FfiConverterString.read(from: &reader), 
                    `key`:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceUploader.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: Uploader
            do {
                cb = try FfiConverterCallbackInterfaceUploader.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Uploader: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeUpload`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: Uploader
            do {
                cb = try FfiConverterCallbackInterfaceUploader.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Uploader: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeDownload`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 3:
            let cb: Uploader
            do {
                cb = try FfiConverterCallbackInterfaceUploader.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Uploader: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeCancelDownload`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 4:
            let cb: Uploader
            do {
                cb = try FfiConverterCallbackInterfaceUploader.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Uploader: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try `invokeCancelUpload`(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceUploader {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_client_fn_init_callback_uploader(foreignCallbackCallbackInterfaceUploader, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<Uploader>()
}

extension FfiConverterCallbackInterfaceUploader : FfiConverter {
    typealias SwiftType = Uploader
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAuthInfo: FfiConverterRustBuffer {
    typealias SwiftType = AuthInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAuthInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAuthInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeContent: FfiConverterRustBuffer {
    typealias SwiftType = Content?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeContent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeContent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTopicNotice: FfiConverterRustBuffer {
    typealias SwiftType = TopicNotice?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTopicNotice.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTopicNotice.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceCallback: FfiConverterRustBuffer {
    typealias SwiftType = Callback?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceCallback.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceCallback.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceUploader: FfiConverterRustBuffer {
    typealias SwiftType = Uploader?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceUploader.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceUploader.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeChatLog: FfiConverterRustBuffer {
    typealias SwiftType = [ChatLog]

    public static func write(_ value: [ChatLog], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeChatLog.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ChatLog] {
        let len: Int32 = try readInt(&buf)
        var seq = [ChatLog]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeChatLog.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeConversation: FfiConverterRustBuffer {
    typealias SwiftType = [Conversation]

    public static func write(_ value: [Conversation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeConversation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Conversation] {
        let len: Int32 = try readInt(&buf)
        var seq = [Conversation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeConversation.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTopicKnock: FfiConverterRustBuffer {
    typealias SwiftType = [TopicKnock]

    public static func write(_ value: [TopicKnock], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTopicKnock.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TopicKnock] {
        let len: Int32 = try readInt(&buf)
        var seq = [TopicKnock]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTopicKnock.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUser: FfiConverterRustBuffer {
    typealias SwiftType = [User]

    public static func write(_ value: [User], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUser.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [User] {
        let len: Int32 = try readInt(&buf)
        var seq = [User]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUser.read(from: &buf))
        }
        return seq
    }
}

public func `initLog`(`level`: String, `isTest`: Bool)  {
    try! rustCall() {
    uniffi_client_fn_func_init_log(
        FfiConverterString.lower(`level`),
        FfiConverterBool.lower(`isTest`),$0)
}
}



public func `getCurrentUser`(`root`: String)  -> AuthInfo? {
    return try!  FfiConverterOptionTypeAuthInfo.lift(
        try! rustCall() {
    uniffi_client_fn_func_get_current_user(
        FfiConverterString.lower(`root`),$0)
}
    )
}

public func `setCurrentUser`(`root`: String, `userId`: String) throws {
    try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_func_set_current_user(
        FfiConverterString.lower(`root`),
        FfiConverterString.lower(`userId`),$0)
}
}



public func `login`(`endpoint`: String, `email`: String, `password`: String) throws -> AuthInfo {
    return try  FfiConverterTypeAuthInfo.lift(
        try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_client_fn_func_login(
        FfiConverterString.lower(`endpoint`),
        FfiConverterString.lower(`email`),
        FfiConverterString.lower(`password`),$0)
}
    )
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 22
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_client_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_client_checksum_func_init_log() != 9358) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_func_get_current_user() != 36766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_func_set_current_user() != 64332) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_func_login() != 28004) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_set_callback() != 55355) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_set_uploader() != 29309) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_prepare() != 33639) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_attach() != 40661) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_app_active() != 53973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_app_deactivate() != 9654) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_logout() != 28478) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_run_loop() != 57808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_shutdown() != 41462) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_get_network_state() != 22572) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_get_topics_knock_count() != 11790) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_get_conversations_count() != 25497) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_get_conversation() != 26005) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_remove_conversation() != 26245) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_set_conversation_sticky() != 24476) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_set_conversation_mute() != 19326) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_set_conversation_read() != 61548) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_get_conversations() != 59859) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_sync_conversations() != 36154) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_get_topic() != 63409) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_get_topic_admins() != 32007) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_get_topic_owner() != 20038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_get_topic_members() != 42408) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_get_chat_logs_desc() != 33827) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_get_chat_log() != 14674) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_search_chat_log() != 60608) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_get_topic_knocks() != 45216) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_create_topic() != 23937) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_create_chat() != 10852) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_update_topic() != 17684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_update_topic_notice() != 32205) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_silent_topic() != 9520) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_silent_topic_member() != 59564) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_add_topic_admin() != 36967) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_remove_topic_admin() != 36592) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_transfer_topic() != 11354) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_quit_topic() != 3650) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_dismiss_topic() != 4383) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_join_topic() != 36228) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_accept_topic_join() != 22619) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_decline_topic_join() != 39967) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_invite_topic_member() != 32627) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_remove_topic_member() != 6374) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_clean_topic_history() != 18125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_remove_messages() != 40827) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_get_user() != 62667) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_set_user_remark() != 9172) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_set_user_star() != 1481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_set_user_block() != 59481) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_set_allow_guest_chat() != 24595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_do_typing() != 63193) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_do_recall() != 14737) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_do_send_text() != 20437) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_do_send_image() != 59928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_do_send_voice() != 60890) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_do_send_video() != 46395) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_do_send_file() != 39341) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_do_send_location() != 23943) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_do_send_link() != 4676) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_do_send() != 12153) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_upload() != 19554) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_download() != 56540) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_cancel_download() != 64461) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_method_client_cancel_upload() != 10332) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_client_checksum_constructor_client_new() != 20644) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}