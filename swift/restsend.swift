// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(restsendFFI)
import restsendFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_restsend_sdk_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_restsend_sdk_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
                throw CancellationError()

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public protocol ClientProtocol {
    func acceptTopicJoin(topicId: String, userId: String, memo: String?) async throws
    func addTopicAdmin(topicId: String, userId: String) async throws
    func addTopicMember(topicId: String, userId: String) async throws -> TopicMember
    func appActive()  
    func appDeactivate()  
    func cancelSend(chatId: String)  
    func cleanMessages(topicId: String) async throws
    func connect() async 
    func connectionStatus()   -> String
    func createChat(userId: String) async throws -> Conversation
    func createTopic(members: [String], icon: String?, name: String?) async throws -> Conversation
    func declineTopicJoin(topicId: String, userId: String, message: String?) async throws
    func dismissTopic(topicId: String) async throws
    func doRead(topicId: String) async throws
    func doRecall(topicId: String, chatId: String, callback: MessageCallback?) async throws -> String
    func doSend(topicId: String, content: Content, callback: MessageCallback?) async throws -> String
    func doSendFile(topicId: String, attachment: Attachment, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws -> String
    func doSendImage(topicId: String, attachment: Attachment, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws -> String
    func doSendInvite(topicId: String, messsage: String?, callback: MessageCallback?) async throws -> String
    func doSendLink(topicId: String, url: String, placeholder: String, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws -> String
    func doSendLocation(topicId: String, latitude: String, longitude: String, address: String, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws -> String
    func doSendLogs(topicId: String, logIds: [String], mentions: [String]?, callback: MessageCallback?) async throws -> String
    func doSendText(topicId: String, text: String, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws -> String
    func doSendVideo(topicId: String, attachment: Attachment, duration: String, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws -> String
    func doSendVoice(topicId: String, attachment: Attachment, duration: String, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws -> String
    func doTyping(topicId: String) async throws
    func downloadFile(fileUrl: String, callback: DownloadCallback) async throws -> String
    func getChatLog(topicId: String, chatId: String)   -> ChatLog?
    func getConversation(topicId: String)   -> Conversation?
    func getTopic(topicId: String) async throws -> Topic
    func getTopicAdmins(topicId: String) async  -> [User]?
    func getTopicKnocks(topicId: String) async  -> [TopicKnock]?
    func getTopicMembers(topicId: String, updatedAt: String, limit: UInt32) async throws -> ListUserResult
    func getTopicOwner(topicId: String) async  -> User?
    func getUser(userId: String, blocking: Bool) async  -> User?
    func getUsers(userIds: [String]) async  -> [User]
    func joinTopic(topicId: String, message: String?, source: String?) async throws
    func quitTopic(topicId: String) async throws
    func removeConversation(topicId: String) async 
    func removeMessages(topicId: String, chatIds: [String], syncToServer: Bool) async throws
    func removeTopicAdmin(topicId: String, userId: String) async throws
    func removeTopicMember(topicId: String, userId: String) async throws
    func searchChatLog(topicId: String?, senderId: String?, keyword: String) async  -> GetChatLogsResult?
    func sendChatRequest(topicId: String, req: ChatRequest) async throws -> ApiSendResponse
    func sendChatRequestViaConnection(req: ChatRequest, callback: MessageCallback?) async throws -> String
    func setAllowGuestChat(allow: Bool) async throws
    func setCallback(callback: Callback?)  
    func setConversationExtra(topicId: String, extra: [String: String]?) async throws -> Conversation
    func setConversationMute(topicId: String, mute: Bool) async throws -> Conversation
    func setConversationRead(topicId: String) async 
    func setConversationRemark(topicId: String, remark: String?) async throws -> Conversation
    func setConversationSticky(topicId: String, sticky: Bool) async throws -> Conversation
    func setConversationTags(topicId: String, tags: [Tag]?) async throws -> Conversation
    func setUserBlock(userId: String, block: Bool) async throws
    func setUserRemark(userId: String, remark: String) async throws
    func setUserStar(userId: String, star: Bool) async throws
    func shutdown()  
    func silentTopic(topicId: String, duration: String?) async throws
    func silentTopicMember(topicId: String, userId: String, duration: String?) async throws
    func syncChatLogs(topicId: String, lastSeq: Int64, limit: UInt32, callback: SyncChatLogsCallback)  
    func syncConversations(updatedAt: String?, limit: UInt32, callback: SyncConversationsCallback)  
    func transferTopic(topicId: String, userId: String) async throws
    func updateTopic(topicId: String, name: String?, icon: String?) async throws
    func updateTopicNotice(topicId: String, text: String) async throws
    
}

public class Client: ClientProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }
    public convenience init(rootPath: String, dbName: String, info: AuthInfo)  {
        self.init(unsafeFromRawPointer: try! rustCall() {
    uniffi_restsend_sdk_fn_constructor_client_new(
        FfiConverterString.lower(rootPath),
        FfiConverterString.lower(dbName),
        FfiConverterTypeAuthInfo.lower(info),$0)
})
    }

    deinit {
        try! rustCall { uniffi_restsend_sdk_fn_free_client(pointer, $0) }
    }

    

    
    

    public func acceptTopicJoin(topicId: String, userId: String, memo: String?) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_accept_topic_join(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterString.lower(userId),
                    FfiConverterOptionString.lower(memo)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func addTopicAdmin(topicId: String, userId: String) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_add_topic_admin(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func addTopicMember(topicId: String, userId: String) async throws -> TopicMember {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_add_topic_member(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTopicMember.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func appActive()  {
        try! 
    rustCall() {
    
    uniffi_restsend_sdk_fn_method_client_app_active(self.pointer, $0
    )
}
    }

    public func appDeactivate()  {
        try! 
    rustCall() {
    
    uniffi_restsend_sdk_fn_method_client_app_deactivate(self.pointer, $0
    )
}
    }

    public func cancelSend(chatId: String)  {
        try! 
    rustCall() {
    
    uniffi_restsend_sdk_fn_method_client_cancel_send(self.pointer, 
        FfiConverterString.lower(chatId),$0
    )
}
    }

    public func cleanMessages(topicId: String) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_clean_messages(
                    self.pointer,
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func connect() async  {
        return try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_connect(
                    self.pointer
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
    }

    

    public func connectionStatus()  -> String {
        return try!  FfiConverterString.lift(
            try! 
    rustCall() {
    
    uniffi_restsend_sdk_fn_method_client_connection_status(self.pointer, $0
    )
}
        )
    }

    public func createChat(userId: String) async throws -> Conversation {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_create_chat(
                    self.pointer,
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeConversation.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func createTopic(members: [String], icon: String?, name: String?) async throws -> Conversation {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_create_topic(
                    self.pointer,
                    FfiConverterSequenceString.lower(members),
                    FfiConverterOptionString.lower(icon),
                    FfiConverterOptionString.lower(name)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeConversation.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func declineTopicJoin(topicId: String, userId: String, message: String?) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_decline_topic_join(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterString.lower(userId),
                    FfiConverterOptionString.lower(message)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func dismissTopic(topicId: String) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_dismiss_topic(
                    self.pointer,
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func doRead(topicId: String) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_read(
                    self.pointer,
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func doRecall(topicId: String, chatId: String, callback: MessageCallback?) async throws -> String {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_recall(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterString.lower(chatId),
                    FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func doSend(topicId: String, content: Content, callback: MessageCallback?) async throws -> String {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterTypeContent.lower(content),
                    FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func doSendFile(topicId: String, attachment: Attachment, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws -> String {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_file(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterTypeAttachment.lower(attachment),
                    FfiConverterOptionSequenceString.lower(mentions),
                    FfiConverterOptionString.lower(replyId),
                    FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func doSendImage(topicId: String, attachment: Attachment, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws -> String {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_image(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterTypeAttachment.lower(attachment),
                    FfiConverterOptionSequenceString.lower(mentions),
                    FfiConverterOptionString.lower(replyId),
                    FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func doSendInvite(topicId: String, messsage: String?, callback: MessageCallback?) async throws -> String {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_invite(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterOptionString.lower(messsage),
                    FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func doSendLink(topicId: String, url: String, placeholder: String, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws -> String {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_link(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterString.lower(url),
                    FfiConverterString.lower(placeholder),
                    FfiConverterOptionSequenceString.lower(mentions),
                    FfiConverterOptionString.lower(replyId),
                    FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func doSendLocation(topicId: String, latitude: String, longitude: String, address: String, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws -> String {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_location(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterString.lower(latitude),
                    FfiConverterString.lower(longitude),
                    FfiConverterString.lower(address),
                    FfiConverterOptionSequenceString.lower(mentions),
                    FfiConverterOptionString.lower(replyId),
                    FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func doSendLogs(topicId: String, logIds: [String], mentions: [String]?, callback: MessageCallback?) async throws -> String {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_logs(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterSequenceString.lower(logIds),
                    FfiConverterOptionSequenceString.lower(mentions),
                    FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func doSendText(topicId: String, text: String, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws -> String {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_text(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterString.lower(text),
                    FfiConverterOptionSequenceString.lower(mentions),
                    FfiConverterOptionString.lower(replyId),
                    FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func doSendVideo(topicId: String, attachment: Attachment, duration: String, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws -> String {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_video(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterTypeAttachment.lower(attachment),
                    FfiConverterString.lower(duration),
                    FfiConverterOptionSequenceString.lower(mentions),
                    FfiConverterOptionString.lower(replyId),
                    FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func doSendVoice(topicId: String, attachment: Attachment, duration: String, mentions: [String]?, replyId: String?, callback: MessageCallback?) async throws -> String {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_send_voice(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterTypeAttachment.lower(attachment),
                    FfiConverterString.lower(duration),
                    FfiConverterOptionSequenceString.lower(mentions),
                    FfiConverterOptionString.lower(replyId),
                    FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func doTyping(topicId: String) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_do_typing(
                    self.pointer,
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func downloadFile(fileUrl: String, callback: DownloadCallback) async throws -> String {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_download_file(
                    self.pointer,
                    FfiConverterString.lower(fileUrl),
                    FfiConverterCallbackInterfaceDownloadCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func getChatLog(topicId: String, chatId: String)  -> ChatLog? {
        return try!  FfiConverterOptionTypeChatLog.lift(
            try! 
    rustCall() {
    
    uniffi_restsend_sdk_fn_method_client_get_chat_log(self.pointer, 
        FfiConverterString.lower(topicId),
        FfiConverterString.lower(chatId),$0
    )
}
        )
    }

    public func getConversation(topicId: String)  -> Conversation? {
        return try!  FfiConverterOptionTypeConversation.lift(
            try! 
    rustCall() {
    
    uniffi_restsend_sdk_fn_method_client_get_conversation(self.pointer, 
        FfiConverterString.lower(topicId),$0
    )
}
        )
    }

    public func getTopic(topicId: String) async throws -> Topic {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_topic(
                    self.pointer,
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeTopic.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func getTopicAdmins(topicId: String) async  -> [User]? {
        return try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_topic_admins(
                    self.pointer,
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceTypeUser.lift,
            errorHandler: nil
            
        )
    }

    

    public func getTopicKnocks(topicId: String) async  -> [TopicKnock]? {
        return try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_topic_knocks(
                    self.pointer,
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceTypeTopicKnock.lift,
            errorHandler: nil
            
        )
    }

    

    public func getTopicMembers(topicId: String, updatedAt: String, limit: UInt32) async throws -> ListUserResult {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_topic_members(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterString.lower(updatedAt),
                    FfiConverterUInt32.lower(limit)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeListUserResult.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func getTopicOwner(topicId: String) async  -> User? {
        return try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_topic_owner(
                    self.pointer,
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeUser.lift,
            errorHandler: nil
            
        )
    }

    

    public func getUser(userId: String, blocking: Bool) async  -> User? {
        return try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_user(
                    self.pointer,
                    FfiConverterString.lower(userId),
                    FfiConverterBool.lower(blocking)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeUser.lift,
            errorHandler: nil
            
        )
    }

    

    public func getUsers(userIds: [String]) async  -> [User] {
        return try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_get_users(
                    self.pointer,
                    FfiConverterSequenceString.lower(userIds)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeUser.lift,
            errorHandler: nil
            
        )
    }

    

    public func joinTopic(topicId: String, message: String?, source: String?) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_join_topic(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterOptionString.lower(message),
                    FfiConverterOptionString.lower(source)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func quitTopic(topicId: String) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_quit_topic(
                    self.pointer,
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func removeConversation(topicId: String) async  {
        return try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_remove_conversation(
                    self.pointer,
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
    }

    

    public func removeMessages(topicId: String, chatIds: [String], syncToServer: Bool) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_remove_messages(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterSequenceString.lower(chatIds),
                    FfiConverterBool.lower(syncToServer)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func removeTopicAdmin(topicId: String, userId: String) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_remove_topic_admin(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func removeTopicMember(topicId: String, userId: String) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_remove_topic_member(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func searchChatLog(topicId: String?, senderId: String?, keyword: String) async  -> GetChatLogsResult? {
        return try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_search_chat_log(
                    self.pointer,
                    FfiConverterOptionString.lower(topicId),
                    FfiConverterOptionString.lower(senderId),
                    FfiConverterString.lower(keyword)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeGetChatLogsResult.lift,
            errorHandler: nil
            
        )
    }

    

    public func sendChatRequest(topicId: String, req: ChatRequest) async throws -> ApiSendResponse {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_send_chat_request(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterTypeChatRequest.lower(req)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeAPISendResponse.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func sendChatRequestViaConnection(req: ChatRequest, callback: MessageCallback?) async throws -> String {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_send_chat_request_via_connection(
                    self.pointer,
                    FfiConverterTypeChatRequest.lower(req),
                    FfiConverterOptionCallbackInterfaceMessageCallback.lower(callback)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func setAllowGuestChat(allow: Bool) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_allow_guest_chat(
                    self.pointer,
                    FfiConverterBool.lower(allow)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func setCallback(callback: Callback?)  {
        try! 
    rustCall() {
    
    uniffi_restsend_sdk_fn_method_client_set_callback(self.pointer, 
        FfiConverterOptionCallbackInterfaceCallback.lower(callback),$0
    )
}
    }

    public func setConversationExtra(topicId: String, extra: [String: String]?) async throws -> Conversation {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_conversation_extra(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterOptionDictionaryStringString.lower(extra)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeConversation.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func setConversationMute(topicId: String, mute: Bool) async throws -> Conversation {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_conversation_mute(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterBool.lower(mute)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeConversation.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func setConversationRead(topicId: String) async  {
        return try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_conversation_read(
                    self.pointer,
                    FfiConverterString.lower(topicId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
    }

    

    public func setConversationRemark(topicId: String, remark: String?) async throws -> Conversation {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_conversation_remark(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterOptionString.lower(remark)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeConversation.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func setConversationSticky(topicId: String, sticky: Bool) async throws -> Conversation {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_conversation_sticky(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterBool.lower(sticky)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeConversation.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func setConversationTags(topicId: String, tags: [Tag]?) async throws -> Conversation {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_conversation_tags(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterOptionSequenceTypeTag.lower(tags)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
            completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
            freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeConversation.lift,
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func setUserBlock(userId: String, block: Bool) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_user_block(
                    self.pointer,
                    FfiConverterString.lower(userId),
                    FfiConverterBool.lower(block)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func setUserRemark(userId: String, remark: String) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_user_remark(
                    self.pointer,
                    FfiConverterString.lower(userId),
                    FfiConverterString.lower(remark)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func setUserStar(userId: String, star: Bool) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_set_user_star(
                    self.pointer,
                    FfiConverterString.lower(userId),
                    FfiConverterBool.lower(star)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func shutdown()  {
        try! 
    rustCall() {
    
    uniffi_restsend_sdk_fn_method_client_shutdown(self.pointer, $0
    )
}
    }

    public func silentTopic(topicId: String, duration: String?) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_silent_topic(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterOptionString.lower(duration)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func silentTopicMember(topicId: String, userId: String, duration: String?) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_silent_topic_member(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterString.lower(userId),
                    FfiConverterOptionString.lower(duration)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func syncChatLogs(topicId: String, lastSeq: Int64, limit: UInt32, callback: SyncChatLogsCallback)  {
        try! 
    rustCall() {
    
    uniffi_restsend_sdk_fn_method_client_sync_chat_logs(self.pointer, 
        FfiConverterString.lower(topicId),
        FfiConverterInt64.lower(lastSeq),
        FfiConverterUInt32.lower(limit),
        FfiConverterCallbackInterfaceSyncChatLogsCallback.lower(callback),$0
    )
}
    }

    public func syncConversations(updatedAt: String?, limit: UInt32, callback: SyncConversationsCallback)  {
        try! 
    rustCall() {
    
    uniffi_restsend_sdk_fn_method_client_sync_conversations(self.pointer, 
        FfiConverterOptionString.lower(updatedAt),
        FfiConverterUInt32.lower(limit),
        FfiConverterCallbackInterfaceSyncConversationsCallback.lower(callback),$0
    )
}
    }

    public func transferTopic(topicId: String, userId: String) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_transfer_topic(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func updateTopic(topicId: String, name: String?, icon: String?) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_update_topic(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterOptionString.lower(name),
                    FfiConverterOptionString.lower(icon)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    

    public func updateTopicNotice(topicId: String, text: String) async throws {
        return try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_restsend_sdk_fn_method_client_update_topic_notice(
                    self.pointer,
                    FfiConverterString.lower(topicId),
                    FfiConverterString.lower(text)
                )
            },
            pollFunc: ffi_restsend_sdk_rust_future_poll_void,
            completeFunc: ffi_restsend_sdk_rust_future_complete_void,
            freeFunc: ffi_restsend_sdk_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError.lift
        )
    }

    
}

public struct FfiConverterTypeClient: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = Client

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
        return Client(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: Client) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}


public func FfiConverterTypeClient_lift(_ pointer: UnsafeMutableRawPointer) throws -> Client {
    return try FfiConverterTypeClient.lift(pointer)
}

public func FfiConverterTypeClient_lower(_ value: Client) -> UnsafeMutableRawPointer {
    return FfiConverterTypeClient.lower(value)
}


public struct ApiSendResponse {
    public var senderId: String
    public var topicId: String
    public var attendeeId: String
    public var chatId: String
    public var code: UInt16
    public var seq: Int64
    public var message: String
    public var usage: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(senderId: String, topicId: String, attendeeId: String, chatId: String, code: UInt16, seq: Int64, message: String, usage: Int64) {
        self.senderId = senderId
        self.topicId = topicId
        self.attendeeId = attendeeId
        self.chatId = chatId
        self.code = code
        self.seq = seq
        self.message = message
        self.usage = usage
    }
}


extension ApiSendResponse: Equatable, Hashable {
    public static func ==(lhs: ApiSendResponse, rhs: ApiSendResponse) -> Bool {
        if lhs.senderId != rhs.senderId {
            return false
        }
        if lhs.topicId != rhs.topicId {
            return false
        }
        if lhs.attendeeId != rhs.attendeeId {
            return false
        }
        if lhs.chatId != rhs.chatId {
            return false
        }
        if lhs.code != rhs.code {
            return false
        }
        if lhs.seq != rhs.seq {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.usage != rhs.usage {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(senderId)
        hasher.combine(topicId)
        hasher.combine(attendeeId)
        hasher.combine(chatId)
        hasher.combine(code)
        hasher.combine(seq)
        hasher.combine(message)
        hasher.combine(usage)
    }
}


public struct FfiConverterTypeAPISendResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ApiSendResponse {
        return try ApiSendResponse(
            senderId: FfiConverterString.read(from: &buf), 
            topicId: FfiConverterString.read(from: &buf), 
            attendeeId: FfiConverterString.read(from: &buf), 
            chatId: FfiConverterString.read(from: &buf), 
            code: FfiConverterUInt16.read(from: &buf), 
            seq: FfiConverterInt64.read(from: &buf), 
            message: FfiConverterString.read(from: &buf), 
            usage: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ApiSendResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.senderId, into: &buf)
        FfiConverterString.write(value.topicId, into: &buf)
        FfiConverterString.write(value.attendeeId, into: &buf)
        FfiConverterString.write(value.chatId, into: &buf)
        FfiConverterUInt16.write(value.code, into: &buf)
        FfiConverterInt64.write(value.seq, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterInt64.write(value.usage, into: &buf)
    }
}


public func FfiConverterTypeAPISendResponse_lift(_ buf: RustBuffer) throws -> ApiSendResponse {
    return try FfiConverterTypeAPISendResponse.lift(buf)
}

public func FfiConverterTypeAPISendResponse_lower(_ value: ApiSendResponse) -> RustBuffer {
    return FfiConverterTypeAPISendResponse.lower(value)
}


public struct Attachment {
    public var url: String
    public var size: Int64
    public var thumbnail: String
    public var fileName: String
    public var filePath: String
    public var urlOrData: String
    public var isPrivate: Bool
    public var status: AttachmentStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, size: Int64, thumbnail: String, fileName: String, filePath: String, urlOrData: String, isPrivate: Bool, status: AttachmentStatus) {
        self.url = url
        self.size = size
        self.thumbnail = thumbnail
        self.fileName = fileName
        self.filePath = filePath
        self.urlOrData = urlOrData
        self.isPrivate = isPrivate
        self.status = status
    }
}


extension Attachment: Equatable, Hashable {
    public static func ==(lhs: Attachment, rhs: Attachment) -> Bool {
        if lhs.url != rhs.url {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.thumbnail != rhs.thumbnail {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        if lhs.filePath != rhs.filePath {
            return false
        }
        if lhs.urlOrData != rhs.urlOrData {
            return false
        }
        if lhs.isPrivate != rhs.isPrivate {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(url)
        hasher.combine(size)
        hasher.combine(thumbnail)
        hasher.combine(fileName)
        hasher.combine(filePath)
        hasher.combine(urlOrData)
        hasher.combine(isPrivate)
        hasher.combine(status)
    }
}


public struct FfiConverterTypeAttachment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Attachment {
        return try Attachment(
            url: FfiConverterString.read(from: &buf), 
            size: FfiConverterInt64.read(from: &buf), 
            thumbnail: FfiConverterString.read(from: &buf), 
            fileName: FfiConverterString.read(from: &buf), 
            filePath: FfiConverterString.read(from: &buf), 
            urlOrData: FfiConverterString.read(from: &buf), 
            isPrivate: FfiConverterBool.read(from: &buf), 
            status: FfiConverterTypeAttachmentStatus.read(from: &buf)
        )
    }

    public static func write(_ value: Attachment, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterInt64.write(value.size, into: &buf)
        FfiConverterString.write(value.thumbnail, into: &buf)
        FfiConverterString.write(value.fileName, into: &buf)
        FfiConverterString.write(value.filePath, into: &buf)
        FfiConverterString.write(value.urlOrData, into: &buf)
        FfiConverterBool.write(value.isPrivate, into: &buf)
        FfiConverterTypeAttachmentStatus.write(value.status, into: &buf)
    }
}


public func FfiConverterTypeAttachment_lift(_ buf: RustBuffer) throws -> Attachment {
    return try FfiConverterTypeAttachment.lift(buf)
}

public func FfiConverterTypeAttachment_lower(_ value: Attachment) -> RustBuffer {
    return FfiConverterTypeAttachment.lower(value)
}


public struct AuthInfo {
    public var endpoint: String
    public var userId: String
    public var avatar: String
    public var name: String
    public var token: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(endpoint: String, userId: String, avatar: String, name: String, token: String) {
        self.endpoint = endpoint
        self.userId = userId
        self.avatar = avatar
        self.name = name
        self.token = token
    }
}


extension AuthInfo: Equatable, Hashable {
    public static func ==(lhs: AuthInfo, rhs: AuthInfo) -> Bool {
        if lhs.endpoint != rhs.endpoint {
            return false
        }
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.avatar != rhs.avatar {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.token != rhs.token {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(endpoint)
        hasher.combine(userId)
        hasher.combine(avatar)
        hasher.combine(name)
        hasher.combine(token)
    }
}


public struct FfiConverterTypeAuthInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthInfo {
        return try AuthInfo(
            endpoint: FfiConverterString.read(from: &buf), 
            userId: FfiConverterString.read(from: &buf), 
            avatar: FfiConverterString.read(from: &buf), 
            name: FfiConverterString.read(from: &buf), 
            token: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AuthInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.endpoint, into: &buf)
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.avatar, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.token, into: &buf)
    }
}


public func FfiConverterTypeAuthInfo_lift(_ buf: RustBuffer) throws -> AuthInfo {
    return try FfiConverterTypeAuthInfo.lift(buf)
}

public func FfiConverterTypeAuthInfo_lower(_ value: AuthInfo) -> RustBuffer {
    return FfiConverterTypeAuthInfo.lower(value)
}


public struct ChatLog {
    public var topicId: String
    public var id: String
    public var seq: Int64
    public var createdAt: String
    public var senderId: String
    public var content: Content
    public var read: Bool
    public var recall: Bool
    public var status: ChatLogStatus
    public var cachedAt: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(topicId: String, id: String, seq: Int64, createdAt: String, senderId: String, content: Content, read: Bool, recall: Bool, status: ChatLogStatus, cachedAt: Int64) {
        self.topicId = topicId
        self.id = id
        self.seq = seq
        self.createdAt = createdAt
        self.senderId = senderId
        self.content = content
        self.read = read
        self.recall = recall
        self.status = status
        self.cachedAt = cachedAt
    }
}


extension ChatLog: Equatable, Hashable {
    public static func ==(lhs: ChatLog, rhs: ChatLog) -> Bool {
        if lhs.topicId != rhs.topicId {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.seq != rhs.seq {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.senderId != rhs.senderId {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.read != rhs.read {
            return false
        }
        if lhs.recall != rhs.recall {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.cachedAt != rhs.cachedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(topicId)
        hasher.combine(id)
        hasher.combine(seq)
        hasher.combine(createdAt)
        hasher.combine(senderId)
        hasher.combine(content)
        hasher.combine(read)
        hasher.combine(recall)
        hasher.combine(status)
        hasher.combine(cachedAt)
    }
}


public struct FfiConverterTypeChatLog: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChatLog {
        return try ChatLog(
            topicId: FfiConverterString.read(from: &buf), 
            id: FfiConverterString.read(from: &buf), 
            seq: FfiConverterInt64.read(from: &buf), 
            createdAt: FfiConverterString.read(from: &buf), 
            senderId: FfiConverterString.read(from: &buf), 
            content: FfiConverterTypeContent.read(from: &buf), 
            read: FfiConverterBool.read(from: &buf), 
            recall: FfiConverterBool.read(from: &buf), 
            status: FfiConverterTypeChatLogStatus.read(from: &buf), 
            cachedAt: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ChatLog, into buf: inout [UInt8]) {
        FfiConverterString.write(value.topicId, into: &buf)
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterInt64.write(value.seq, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.senderId, into: &buf)
        FfiConverterTypeContent.write(value.content, into: &buf)
        FfiConverterBool.write(value.read, into: &buf)
        FfiConverterBool.write(value.recall, into: &buf)
        FfiConverterTypeChatLogStatus.write(value.status, into: &buf)
        FfiConverterInt64.write(value.cachedAt, into: &buf)
    }
}


public func FfiConverterTypeChatLog_lift(_ buf: RustBuffer) throws -> ChatLog {
    return try FfiConverterTypeChatLog.lift(buf)
}

public func FfiConverterTypeChatLog_lower(_ value: ChatLog) -> RustBuffer {
    return FfiConverterTypeChatLog.lower(value)
}


public struct ChatRequest {
    public var type: String
    public var chatId: String
    public var code: UInt32
    public var topicId: String
    public var seq: Int64
    public var attendee: String
    public var attendeeProfile: User?
    public var createdAt: String
    public var content: Content?
    public var e2eContent: String?
    public var message: String?
    public var source: String?
    public var unreadable: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(type: String, chatId: String, code: UInt32, topicId: String, seq: Int64, attendee: String, attendeeProfile: User?, createdAt: String, content: Content?, e2eContent: String?, message: String?, source: String?, unreadable: Bool) {
        self.type = type
        self.chatId = chatId
        self.code = code
        self.topicId = topicId
        self.seq = seq
        self.attendee = attendee
        self.attendeeProfile = attendeeProfile
        self.createdAt = createdAt
        self.content = content
        self.e2eContent = e2eContent
        self.message = message
        self.source = source
        self.unreadable = unreadable
    }
}


extension ChatRequest: Equatable, Hashable {
    public static func ==(lhs: ChatRequest, rhs: ChatRequest) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        if lhs.chatId != rhs.chatId {
            return false
        }
        if lhs.code != rhs.code {
            return false
        }
        if lhs.topicId != rhs.topicId {
            return false
        }
        if lhs.seq != rhs.seq {
            return false
        }
        if lhs.attendee != rhs.attendee {
            return false
        }
        if lhs.attendeeProfile != rhs.attendeeProfile {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.e2eContent != rhs.e2eContent {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.unreadable != rhs.unreadable {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
        hasher.combine(chatId)
        hasher.combine(code)
        hasher.combine(topicId)
        hasher.combine(seq)
        hasher.combine(attendee)
        hasher.combine(attendeeProfile)
        hasher.combine(createdAt)
        hasher.combine(content)
        hasher.combine(e2eContent)
        hasher.combine(message)
        hasher.combine(source)
        hasher.combine(unreadable)
    }
}


public struct FfiConverterTypeChatRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChatRequest {
        return try ChatRequest(
            type: FfiConverterString.read(from: &buf), 
            chatId: FfiConverterString.read(from: &buf), 
            code: FfiConverterUInt32.read(from: &buf), 
            topicId: FfiConverterString.read(from: &buf), 
            seq: FfiConverterInt64.read(from: &buf), 
            attendee: FfiConverterString.read(from: &buf), 
            attendeeProfile: FfiConverterOptionTypeUser.read(from: &buf), 
            createdAt: FfiConverterString.read(from: &buf), 
            content: FfiConverterOptionTypeContent.read(from: &buf), 
            e2eContent: FfiConverterOptionString.read(from: &buf), 
            message: FfiConverterOptionString.read(from: &buf), 
            source: FfiConverterOptionString.read(from: &buf), 
            unreadable: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ChatRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.type, into: &buf)
        FfiConverterString.write(value.chatId, into: &buf)
        FfiConverterUInt32.write(value.code, into: &buf)
        FfiConverterString.write(value.topicId, into: &buf)
        FfiConverterInt64.write(value.seq, into: &buf)
        FfiConverterString.write(value.attendee, into: &buf)
        FfiConverterOptionTypeUser.write(value.attendeeProfile, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterOptionTypeContent.write(value.content, into: &buf)
        FfiConverterOptionString.write(value.e2eContent, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterOptionString.write(value.source, into: &buf)
        FfiConverterBool.write(value.unreadable, into: &buf)
    }
}


public func FfiConverterTypeChatRequest_lift(_ buf: RustBuffer) throws -> ChatRequest {
    return try FfiConverterTypeChatRequest.lift(buf)
}

public func FfiConverterTypeChatRequest_lower(_ value: ChatRequest) -> RustBuffer {
    return FfiConverterTypeChatRequest.lower(value)
}


public struct Content {
    public var type: String
    public var encrypted: Bool
    public var checksum: UInt32
    public var text: String
    public var placeholder: String
    public var thumbnail: String
    public var duration: String
    public var size: UInt64
    public var width: Float
    public var height: Float
    public var mentions: [String]
    public var mentionAll: Bool
    public var reply: String
    public var createdAt: String
    public var attachment: Attachment?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(type: String, encrypted: Bool, checksum: UInt32, text: String, placeholder: String, thumbnail: String, duration: String, size: UInt64, width: Float, height: Float, mentions: [String], mentionAll: Bool, reply: String, createdAt: String, attachment: Attachment?) {
        self.type = type
        self.encrypted = encrypted
        self.checksum = checksum
        self.text = text
        self.placeholder = placeholder
        self.thumbnail = thumbnail
        self.duration = duration
        self.size = size
        self.width = width
        self.height = height
        self.mentions = mentions
        self.mentionAll = mentionAll
        self.reply = reply
        self.createdAt = createdAt
        self.attachment = attachment
    }
}


extension Content: Equatable, Hashable {
    public static func ==(lhs: Content, rhs: Content) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        if lhs.encrypted != rhs.encrypted {
            return false
        }
        if lhs.checksum != rhs.checksum {
            return false
        }
        if lhs.text != rhs.text {
            return false
        }
        if lhs.placeholder != rhs.placeholder {
            return false
        }
        if lhs.thumbnail != rhs.thumbnail {
            return false
        }
        if lhs.duration != rhs.duration {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        if lhs.mentions != rhs.mentions {
            return false
        }
        if lhs.mentionAll != rhs.mentionAll {
            return false
        }
        if lhs.reply != rhs.reply {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.attachment != rhs.attachment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
        hasher.combine(encrypted)
        hasher.combine(checksum)
        hasher.combine(text)
        hasher.combine(placeholder)
        hasher.combine(thumbnail)
        hasher.combine(duration)
        hasher.combine(size)
        hasher.combine(width)
        hasher.combine(height)
        hasher.combine(mentions)
        hasher.combine(mentionAll)
        hasher.combine(reply)
        hasher.combine(createdAt)
        hasher.combine(attachment)
    }
}


public struct FfiConverterTypeContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Content {
        return try Content(
            type: FfiConverterString.read(from: &buf), 
            encrypted: FfiConverterBool.read(from: &buf), 
            checksum: FfiConverterUInt32.read(from: &buf), 
            text: FfiConverterString.read(from: &buf), 
            placeholder: FfiConverterString.read(from: &buf), 
            thumbnail: FfiConverterString.read(from: &buf), 
            duration: FfiConverterString.read(from: &buf), 
            size: FfiConverterUInt64.read(from: &buf), 
            width: FfiConverterFloat.read(from: &buf), 
            height: FfiConverterFloat.read(from: &buf), 
            mentions: FfiConverterSequenceString.read(from: &buf), 
            mentionAll: FfiConverterBool.read(from: &buf), 
            reply: FfiConverterString.read(from: &buf), 
            createdAt: FfiConverterString.read(from: &buf), 
            attachment: FfiConverterOptionTypeAttachment.read(from: &buf)
        )
    }

    public static func write(_ value: Content, into buf: inout [UInt8]) {
        FfiConverterString.write(value.type, into: &buf)
        FfiConverterBool.write(value.encrypted, into: &buf)
        FfiConverterUInt32.write(value.checksum, into: &buf)
        FfiConverterString.write(value.text, into: &buf)
        FfiConverterString.write(value.placeholder, into: &buf)
        FfiConverterString.write(value.thumbnail, into: &buf)
        FfiConverterString.write(value.duration, into: &buf)
        FfiConverterUInt64.write(value.size, into: &buf)
        FfiConverterFloat.write(value.width, into: &buf)
        FfiConverterFloat.write(value.height, into: &buf)
        FfiConverterSequenceString.write(value.mentions, into: &buf)
        FfiConverterBool.write(value.mentionAll, into: &buf)
        FfiConverterString.write(value.reply, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterOptionTypeAttachment.write(value.attachment, into: &buf)
    }
}


public func FfiConverterTypeContent_lift(_ buf: RustBuffer) throws -> Content {
    return try FfiConverterTypeContent.lift(buf)
}

public func FfiConverterTypeContent_lower(_ value: Content) -> RustBuffer {
    return FfiConverterTypeContent.lower(value)
}


public struct Conversation {
    public var ownerId: String
    public var topicId: String
    public var updatedAt: String
    public var lastSeq: Int64
    public var lastReadSeq: Int64
    public var multiple: Bool
    public var attendee: String
    public var members: Int64
    public var name: String
    public var icon: String
    public var sticky: Bool
    public var mute: Bool
    public var source: String
    public var unread: Int64
    public var lastSenderId: String
    public var lastMessage: Content?
    public var lastMessageAt: String
    public var remark: String?
    public var extra: [String: String]?
    public var tags: [Tag]?
    public var cachedAt: Int64
    public var isPartial: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ownerId: String, topicId: String, updatedAt: String, lastSeq: Int64, lastReadSeq: Int64, multiple: Bool, attendee: String, members: Int64, name: String, icon: String, sticky: Bool, mute: Bool, source: String, unread: Int64, lastSenderId: String, lastMessage: Content?, lastMessageAt: String, remark: String?, extra: [String: String]?, tags: [Tag]?, cachedAt: Int64, isPartial: Bool) {
        self.ownerId = ownerId
        self.topicId = topicId
        self.updatedAt = updatedAt
        self.lastSeq = lastSeq
        self.lastReadSeq = lastReadSeq
        self.multiple = multiple
        self.attendee = attendee
        self.members = members
        self.name = name
        self.icon = icon
        self.sticky = sticky
        self.mute = mute
        self.source = source
        self.unread = unread
        self.lastSenderId = lastSenderId
        self.lastMessage = lastMessage
        self.lastMessageAt = lastMessageAt
        self.remark = remark
        self.extra = extra
        self.tags = tags
        self.cachedAt = cachedAt
        self.isPartial = isPartial
    }
}


extension Conversation: Equatable, Hashable {
    public static func ==(lhs: Conversation, rhs: Conversation) -> Bool {
        if lhs.ownerId != rhs.ownerId {
            return false
        }
        if lhs.topicId != rhs.topicId {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.lastSeq != rhs.lastSeq {
            return false
        }
        if lhs.lastReadSeq != rhs.lastReadSeq {
            return false
        }
        if lhs.multiple != rhs.multiple {
            return false
        }
        if lhs.attendee != rhs.attendee {
            return false
        }
        if lhs.members != rhs.members {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        if lhs.sticky != rhs.sticky {
            return false
        }
        if lhs.mute != rhs.mute {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.unread != rhs.unread {
            return false
        }
        if lhs.lastSenderId != rhs.lastSenderId {
            return false
        }
        if lhs.lastMessage != rhs.lastMessage {
            return false
        }
        if lhs.lastMessageAt != rhs.lastMessageAt {
            return false
        }
        if lhs.remark != rhs.remark {
            return false
        }
        if lhs.extra != rhs.extra {
            return false
        }
        if lhs.tags != rhs.tags {
            return false
        }
        if lhs.cachedAt != rhs.cachedAt {
            return false
        }
        if lhs.isPartial != rhs.isPartial {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ownerId)
        hasher.combine(topicId)
        hasher.combine(updatedAt)
        hasher.combine(lastSeq)
        hasher.combine(lastReadSeq)
        hasher.combine(multiple)
        hasher.combine(attendee)
        hasher.combine(members)
        hasher.combine(name)
        hasher.combine(icon)
        hasher.combine(sticky)
        hasher.combine(mute)
        hasher.combine(source)
        hasher.combine(unread)
        hasher.combine(lastSenderId)
        hasher.combine(lastMessage)
        hasher.combine(lastMessageAt)
        hasher.combine(remark)
        hasher.combine(extra)
        hasher.combine(tags)
        hasher.combine(cachedAt)
        hasher.combine(isPartial)
    }
}


public struct FfiConverterTypeConversation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Conversation {
        return try Conversation(
            ownerId: FfiConverterString.read(from: &buf), 
            topicId: FfiConverterString.read(from: &buf), 
            updatedAt: FfiConverterString.read(from: &buf), 
            lastSeq: FfiConverterInt64.read(from: &buf), 
            lastReadSeq: FfiConverterInt64.read(from: &buf), 
            multiple: FfiConverterBool.read(from: &buf), 
            attendee: FfiConverterString.read(from: &buf), 
            members: FfiConverterInt64.read(from: &buf), 
            name: FfiConverterString.read(from: &buf), 
            icon: FfiConverterString.read(from: &buf), 
            sticky: FfiConverterBool.read(from: &buf), 
            mute: FfiConverterBool.read(from: &buf), 
            source: FfiConverterString.read(from: &buf), 
            unread: FfiConverterInt64.read(from: &buf), 
            lastSenderId: FfiConverterString.read(from: &buf), 
            lastMessage: FfiConverterOptionTypeContent.read(from: &buf), 
            lastMessageAt: FfiConverterString.read(from: &buf), 
            remark: FfiConverterOptionString.read(from: &buf), 
            extra: FfiConverterOptionDictionaryStringString.read(from: &buf), 
            tags: FfiConverterOptionSequenceTypeTag.read(from: &buf), 
            cachedAt: FfiConverterInt64.read(from: &buf), 
            isPartial: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Conversation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.ownerId, into: &buf)
        FfiConverterString.write(value.topicId, into: &buf)
        FfiConverterString.write(value.updatedAt, into: &buf)
        FfiConverterInt64.write(value.lastSeq, into: &buf)
        FfiConverterInt64.write(value.lastReadSeq, into: &buf)
        FfiConverterBool.write(value.multiple, into: &buf)
        FfiConverterString.write(value.attendee, into: &buf)
        FfiConverterInt64.write(value.members, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.icon, into: &buf)
        FfiConverterBool.write(value.sticky, into: &buf)
        FfiConverterBool.write(value.mute, into: &buf)
        FfiConverterString.write(value.source, into: &buf)
        FfiConverterInt64.write(value.unread, into: &buf)
        FfiConverterString.write(value.lastSenderId, into: &buf)
        FfiConverterOptionTypeContent.write(value.lastMessage, into: &buf)
        FfiConverterString.write(value.lastMessageAt, into: &buf)
        FfiConverterOptionString.write(value.remark, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.extra, into: &buf)
        FfiConverterOptionSequenceTypeTag.write(value.tags, into: &buf)
        FfiConverterInt64.write(value.cachedAt, into: &buf)
        FfiConverterBool.write(value.isPartial, into: &buf)
    }
}


public func FfiConverterTypeConversation_lift(_ buf: RustBuffer) throws -> Conversation {
    return try FfiConverterTypeConversation.lift(buf)
}

public func FfiConverterTypeConversation_lower(_ value: Conversation) -> RustBuffer {
    return FfiConverterTypeConversation.lower(value)
}


public struct GetChatLogsResult {
    public var hasMore: Bool
    public var startSeq: Int64
    public var endSeq: Int64
    public var items: [ChatLog]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hasMore: Bool, startSeq: Int64, endSeq: Int64, items: [ChatLog]) {
        self.hasMore = hasMore
        self.startSeq = startSeq
        self.endSeq = endSeq
        self.items = items
    }
}


extension GetChatLogsResult: Equatable, Hashable {
    public static func ==(lhs: GetChatLogsResult, rhs: GetChatLogsResult) -> Bool {
        if lhs.hasMore != rhs.hasMore {
            return false
        }
        if lhs.startSeq != rhs.startSeq {
            return false
        }
        if lhs.endSeq != rhs.endSeq {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hasMore)
        hasher.combine(startSeq)
        hasher.combine(endSeq)
        hasher.combine(items)
    }
}


public struct FfiConverterTypeGetChatLogsResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetChatLogsResult {
        return try GetChatLogsResult(
            hasMore: FfiConverterBool.read(from: &buf), 
            startSeq: FfiConverterInt64.read(from: &buf), 
            endSeq: FfiConverterInt64.read(from: &buf), 
            items: FfiConverterSequenceTypeChatLog.read(from: &buf)
        )
    }

    public static func write(_ value: GetChatLogsResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.hasMore, into: &buf)
        FfiConverterInt64.write(value.startSeq, into: &buf)
        FfiConverterInt64.write(value.endSeq, into: &buf)
        FfiConverterSequenceTypeChatLog.write(value.items, into: &buf)
    }
}


public func FfiConverterTypeGetChatLogsResult_lift(_ buf: RustBuffer) throws -> GetChatLogsResult {
    return try FfiConverterTypeGetChatLogsResult.lift(buf)
}

public func FfiConverterTypeGetChatLogsResult_lower(_ value: GetChatLogsResult) -> RustBuffer {
    return FfiConverterTypeGetChatLogsResult.lower(value)
}


public struct ListUserResult {
    public var hasMore: Bool
    public var updatedAt: String
    public var items: [User]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hasMore: Bool, updatedAt: String, items: [User]) {
        self.hasMore = hasMore
        self.updatedAt = updatedAt
        self.items = items
    }
}


extension ListUserResult: Equatable, Hashable {
    public static func ==(lhs: ListUserResult, rhs: ListUserResult) -> Bool {
        if lhs.hasMore != rhs.hasMore {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hasMore)
        hasher.combine(updatedAt)
        hasher.combine(items)
    }
}


public struct FfiConverterTypeListUserResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ListUserResult {
        return try ListUserResult(
            hasMore: FfiConverterBool.read(from: &buf), 
            updatedAt: FfiConverterString.read(from: &buf), 
            items: FfiConverterSequenceTypeUser.read(from: &buf)
        )
    }

    public static func write(_ value: ListUserResult, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.hasMore, into: &buf)
        FfiConverterString.write(value.updatedAt, into: &buf)
        FfiConverterSequenceTypeUser.write(value.items, into: &buf)
    }
}


public func FfiConverterTypeListUserResult_lift(_ buf: RustBuffer) throws -> ListUserResult {
    return try FfiConverterTypeListUserResult.lift(buf)
}

public func FfiConverterTypeListUserResult_lower(_ value: ListUserResult) -> RustBuffer {
    return FfiConverterTypeListUserResult.lower(value)
}


public struct Tag {
    public var id: String
    public var type: String
    public var label: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, type: String, label: String) {
        self.id = id
        self.type = type
        self.label = label
    }
}


extension Tag: Equatable, Hashable {
    public static func ==(lhs: Tag, rhs: Tag) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.label != rhs.label {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(type)
        hasher.combine(label)
    }
}


public struct FfiConverterTypeTag: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tag {
        return try Tag(
            id: FfiConverterString.read(from: &buf), 
            type: FfiConverterString.read(from: &buf), 
            label: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: Tag, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.type, into: &buf)
        FfiConverterString.write(value.label, into: &buf)
    }
}


public func FfiConverterTypeTag_lift(_ buf: RustBuffer) throws -> Tag {
    return try FfiConverterTypeTag.lift(buf)
}

public func FfiConverterTypeTag_lower(_ value: Tag) -> RustBuffer {
    return FfiConverterTypeTag.lower(value)
}


public struct Topic {
    public var id: String
    public var name: String
    public var icon: String
    public var remark: String
    public var ownerId: String
    public var attendeeId: String
    public var admins: [String]
    public var members: UInt32
    public var lastSeq: Int64
    public var multiple: Bool
    public var source: String
    public var `private`: Bool
    public var createdAt: String
    public var updatedAt: String
    public var notice: TopicNotice?
    public var silent: Bool
    public var cachedAt: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, name: String, icon: String, remark: String, ownerId: String, attendeeId: String, admins: [String], members: UInt32, lastSeq: Int64, multiple: Bool, source: String, `private`: Bool, createdAt: String, updatedAt: String, notice: TopicNotice?, silent: Bool, cachedAt: Int64) {
        self.id = id
        self.name = name
        self.icon = icon
        self.remark = remark
        self.ownerId = ownerId
        self.attendeeId = attendeeId
        self.admins = admins
        self.members = members
        self.lastSeq = lastSeq
        self.multiple = multiple
        self.source = source
        self.`private` = `private`
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.notice = notice
        self.silent = silent
        self.cachedAt = cachedAt
    }
}


extension Topic: Equatable, Hashable {
    public static func ==(lhs: Topic, rhs: Topic) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        if lhs.remark != rhs.remark {
            return false
        }
        if lhs.ownerId != rhs.ownerId {
            return false
        }
        if lhs.attendeeId != rhs.attendeeId {
            return false
        }
        if lhs.admins != rhs.admins {
            return false
        }
        if lhs.members != rhs.members {
            return false
        }
        if lhs.lastSeq != rhs.lastSeq {
            return false
        }
        if lhs.multiple != rhs.multiple {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.`private` != rhs.`private` {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.notice != rhs.notice {
            return false
        }
        if lhs.silent != rhs.silent {
            return false
        }
        if lhs.cachedAt != rhs.cachedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(icon)
        hasher.combine(remark)
        hasher.combine(ownerId)
        hasher.combine(attendeeId)
        hasher.combine(admins)
        hasher.combine(members)
        hasher.combine(lastSeq)
        hasher.combine(multiple)
        hasher.combine(source)
        hasher.combine(`private`)
        hasher.combine(createdAt)
        hasher.combine(updatedAt)
        hasher.combine(notice)
        hasher.combine(silent)
        hasher.combine(cachedAt)
    }
}


public struct FfiConverterTypeTopic: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Topic {
        return try Topic(
            id: FfiConverterString.read(from: &buf), 
            name: FfiConverterString.read(from: &buf), 
            icon: FfiConverterString.read(from: &buf), 
            remark: FfiConverterString.read(from: &buf), 
            ownerId: FfiConverterString.read(from: &buf), 
            attendeeId: FfiConverterString.read(from: &buf), 
            admins: FfiConverterSequenceString.read(from: &buf), 
            members: FfiConverterUInt32.read(from: &buf), 
            lastSeq: FfiConverterInt64.read(from: &buf), 
            multiple: FfiConverterBool.read(from: &buf), 
            source: FfiConverterString.read(from: &buf), 
            private: FfiConverterBool.read(from: &buf), 
            createdAt: FfiConverterString.read(from: &buf), 
            updatedAt: FfiConverterString.read(from: &buf), 
            notice: FfiConverterOptionTypeTopicNotice.read(from: &buf), 
            silent: FfiConverterBool.read(from: &buf), 
            cachedAt: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Topic, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.icon, into: &buf)
        FfiConverterString.write(value.remark, into: &buf)
        FfiConverterString.write(value.ownerId, into: &buf)
        FfiConverterString.write(value.attendeeId, into: &buf)
        FfiConverterSequenceString.write(value.admins, into: &buf)
        FfiConverterUInt32.write(value.members, into: &buf)
        FfiConverterInt64.write(value.lastSeq, into: &buf)
        FfiConverterBool.write(value.multiple, into: &buf)
        FfiConverterString.write(value.source, into: &buf)
        FfiConverterBool.write(value.`private`, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.updatedAt, into: &buf)
        FfiConverterOptionTypeTopicNotice.write(value.notice, into: &buf)
        FfiConverterBool.write(value.silent, into: &buf)
        FfiConverterInt64.write(value.cachedAt, into: &buf)
    }
}


public func FfiConverterTypeTopic_lift(_ buf: RustBuffer) throws -> Topic {
    return try FfiConverterTypeTopic.lift(buf)
}

public func FfiConverterTypeTopic_lower(_ value: Topic) -> RustBuffer {
    return FfiConverterTypeTopic.lower(value)
}


public struct TopicKnock {
    public var createdAt: String
    public var updatedAt: String
    public var topicId: String
    public var userId: String
    public var message: String
    public var source: String
    public var status: String
    public var adminId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(createdAt: String, updatedAt: String, topicId: String, userId: String, message: String, source: String, status: String, adminId: String) {
        self.createdAt = createdAt
        self.updatedAt = updatedAt
        self.topicId = topicId
        self.userId = userId
        self.message = message
        self.source = source
        self.status = status
        self.adminId = adminId
    }
}


extension TopicKnock: Equatable, Hashable {
    public static func ==(lhs: TopicKnock, rhs: TopicKnock) -> Bool {
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.topicId != rhs.topicId {
            return false
        }
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        if lhs.adminId != rhs.adminId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(createdAt)
        hasher.combine(updatedAt)
        hasher.combine(topicId)
        hasher.combine(userId)
        hasher.combine(message)
        hasher.combine(source)
        hasher.combine(status)
        hasher.combine(adminId)
    }
}


public struct FfiConverterTypeTopicKnock: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TopicKnock {
        return try TopicKnock(
            createdAt: FfiConverterString.read(from: &buf), 
            updatedAt: FfiConverterString.read(from: &buf), 
            topicId: FfiConverterString.read(from: &buf), 
            userId: FfiConverterString.read(from: &buf), 
            message: FfiConverterString.read(from: &buf), 
            source: FfiConverterString.read(from: &buf), 
            status: FfiConverterString.read(from: &buf), 
            adminId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TopicKnock, into buf: inout [UInt8]) {
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.updatedAt, into: &buf)
        FfiConverterString.write(value.topicId, into: &buf)
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.message, into: &buf)
        FfiConverterString.write(value.source, into: &buf)
        FfiConverterString.write(value.status, into: &buf)
        FfiConverterString.write(value.adminId, into: &buf)
    }
}


public func FfiConverterTypeTopicKnock_lift(_ buf: RustBuffer) throws -> TopicKnock {
    return try FfiConverterTypeTopicKnock.lift(buf)
}

public func FfiConverterTypeTopicKnock_lower(_ value: TopicKnock) -> RustBuffer {
    return FfiConverterTypeTopicKnock.lower(value)
}


public struct TopicMember {
    public var topicId: String
    public var userId: String
    public var name: String
    public var source: String
    public var silenceAt: String?
    public var joinedAt: String
    public var updatedAt: String
    public var extra: [String: String]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(topicId: String, userId: String, name: String, source: String, silenceAt: String?, joinedAt: String, updatedAt: String, extra: [String: String]?) {
        self.topicId = topicId
        self.userId = userId
        self.name = name
        self.source = source
        self.silenceAt = silenceAt
        self.joinedAt = joinedAt
        self.updatedAt = updatedAt
        self.extra = extra
    }
}


extension TopicMember: Equatable, Hashable {
    public static func ==(lhs: TopicMember, rhs: TopicMember) -> Bool {
        if lhs.topicId != rhs.topicId {
            return false
        }
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.silenceAt != rhs.silenceAt {
            return false
        }
        if lhs.joinedAt != rhs.joinedAt {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.extra != rhs.extra {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(topicId)
        hasher.combine(userId)
        hasher.combine(name)
        hasher.combine(source)
        hasher.combine(silenceAt)
        hasher.combine(joinedAt)
        hasher.combine(updatedAt)
        hasher.combine(extra)
    }
}


public struct FfiConverterTypeTopicMember: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TopicMember {
        return try TopicMember(
            topicId: FfiConverterString.read(from: &buf), 
            userId: FfiConverterString.read(from: &buf), 
            name: FfiConverterString.read(from: &buf), 
            source: FfiConverterString.read(from: &buf), 
            silenceAt: FfiConverterOptionString.read(from: &buf), 
            joinedAt: FfiConverterString.read(from: &buf), 
            updatedAt: FfiConverterString.read(from: &buf), 
            extra: FfiConverterOptionDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: TopicMember, into buf: inout [UInt8]) {
        FfiConverterString.write(value.topicId, into: &buf)
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.source, into: &buf)
        FfiConverterOptionString.write(value.silenceAt, into: &buf)
        FfiConverterString.write(value.joinedAt, into: &buf)
        FfiConverterString.write(value.updatedAt, into: &buf)
        FfiConverterOptionDictionaryStringString.write(value.extra, into: &buf)
    }
}


public func FfiConverterTypeTopicMember_lift(_ buf: RustBuffer) throws -> TopicMember {
    return try FfiConverterTypeTopicMember.lift(buf)
}

public func FfiConverterTypeTopicMember_lower(_ value: TopicMember) -> RustBuffer {
    return FfiConverterTypeTopicMember.lower(value)
}


public struct TopicNotice {
    public var text: String
    public var publisher: String
    public var updatedAt: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(text: String, publisher: String, updatedAt: String) {
        self.text = text
        self.publisher = publisher
        self.updatedAt = updatedAt
    }
}


extension TopicNotice: Equatable, Hashable {
    public static func ==(lhs: TopicNotice, rhs: TopicNotice) -> Bool {
        if lhs.text != rhs.text {
            return false
        }
        if lhs.publisher != rhs.publisher {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(text)
        hasher.combine(publisher)
        hasher.combine(updatedAt)
    }
}


public struct FfiConverterTypeTopicNotice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TopicNotice {
        return try TopicNotice(
            text: FfiConverterString.read(from: &buf), 
            publisher: FfiConverterString.read(from: &buf), 
            updatedAt: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TopicNotice, into buf: inout [UInt8]) {
        FfiConverterString.write(value.text, into: &buf)
        FfiConverterString.write(value.publisher, into: &buf)
        FfiConverterString.write(value.updatedAt, into: &buf)
    }
}


public func FfiConverterTypeTopicNotice_lift(_ buf: RustBuffer) throws -> TopicNotice {
    return try FfiConverterTypeTopicNotice.lift(buf)
}

public func FfiConverterTypeTopicNotice_lower(_ value: TopicNotice) -> RustBuffer {
    return FfiConverterTypeTopicNotice.lower(value)
}


public struct Upload {
    public var path: String
    public var fileName: String
    public var thumbnail: String
    public var ext: String
    public var size: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(path: String, fileName: String, thumbnail: String, ext: String, size: UInt64) {
        self.path = path
        self.fileName = fileName
        self.thumbnail = thumbnail
        self.ext = ext
        self.size = size
    }
}


extension Upload: Equatable, Hashable {
    public static func ==(lhs: Upload, rhs: Upload) -> Bool {
        if lhs.path != rhs.path {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        if lhs.thumbnail != rhs.thumbnail {
            return false
        }
        if lhs.ext != rhs.ext {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(path)
        hasher.combine(fileName)
        hasher.combine(thumbnail)
        hasher.combine(ext)
        hasher.combine(size)
    }
}


public struct FfiConverterTypeUpload: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Upload {
        return try Upload(
            path: FfiConverterString.read(from: &buf), 
            fileName: FfiConverterString.read(from: &buf), 
            thumbnail: FfiConverterString.read(from: &buf), 
            ext: FfiConverterString.read(from: &buf), 
            size: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: Upload, into buf: inout [UInt8]) {
        FfiConverterString.write(value.path, into: &buf)
        FfiConverterString.write(value.fileName, into: &buf)
        FfiConverterString.write(value.thumbnail, into: &buf)
        FfiConverterString.write(value.ext, into: &buf)
        FfiConverterUInt64.write(value.size, into: &buf)
    }
}


public func FfiConverterTypeUpload_lift(_ buf: RustBuffer) throws -> Upload {
    return try FfiConverterTypeUpload.lift(buf)
}

public func FfiConverterTypeUpload_lower(_ value: Upload) -> RustBuffer {
    return FfiConverterTypeUpload.lower(value)
}


public struct User {
    public var userId: String
    public var name: String
    public var avatar: String
    public var publicKey: String
    public var remark: String
    public var isContact: Bool
    public var isStar: Bool
    public var isBlocked: Bool
    public var locale: String
    public var city: String
    public var country: String
    public var source: String
    public var createdAt: String
    public var gender: String
    public var cachedAt: Int64
    public var isPartial: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userId: String, name: String, avatar: String, publicKey: String, remark: String, isContact: Bool, isStar: Bool, isBlocked: Bool, locale: String, city: String, country: String, source: String, createdAt: String, gender: String, cachedAt: Int64, isPartial: Bool) {
        self.userId = userId
        self.name = name
        self.avatar = avatar
        self.publicKey = publicKey
        self.remark = remark
        self.isContact = isContact
        self.isStar = isStar
        self.isBlocked = isBlocked
        self.locale = locale
        self.city = city
        self.country = country
        self.source = source
        self.createdAt = createdAt
        self.gender = gender
        self.cachedAt = cachedAt
        self.isPartial = isPartial
    }
}


extension User: Equatable, Hashable {
    public static func ==(lhs: User, rhs: User) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.avatar != rhs.avatar {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.remark != rhs.remark {
            return false
        }
        if lhs.isContact != rhs.isContact {
            return false
        }
        if lhs.isStar != rhs.isStar {
            return false
        }
        if lhs.isBlocked != rhs.isBlocked {
            return false
        }
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.city != rhs.city {
            return false
        }
        if lhs.country != rhs.country {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.gender != rhs.gender {
            return false
        }
        if lhs.cachedAt != rhs.cachedAt {
            return false
        }
        if lhs.isPartial != rhs.isPartial {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(name)
        hasher.combine(avatar)
        hasher.combine(publicKey)
        hasher.combine(remark)
        hasher.combine(isContact)
        hasher.combine(isStar)
        hasher.combine(isBlocked)
        hasher.combine(locale)
        hasher.combine(city)
        hasher.combine(country)
        hasher.combine(source)
        hasher.combine(createdAt)
        hasher.combine(gender)
        hasher.combine(cachedAt)
        hasher.combine(isPartial)
    }
}


public struct FfiConverterTypeUser: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> User {
        return try User(
            userId: FfiConverterString.read(from: &buf), 
            name: FfiConverterString.read(from: &buf), 
            avatar: FfiConverterString.read(from: &buf), 
            publicKey: FfiConverterString.read(from: &buf), 
            remark: FfiConverterString.read(from: &buf), 
            isContact: FfiConverterBool.read(from: &buf), 
            isStar: FfiConverterBool.read(from: &buf), 
            isBlocked: FfiConverterBool.read(from: &buf), 
            locale: FfiConverterString.read(from: &buf), 
            city: FfiConverterString.read(from: &buf), 
            country: FfiConverterString.read(from: &buf), 
            source: FfiConverterString.read(from: &buf), 
            createdAt: FfiConverterString.read(from: &buf), 
            gender: FfiConverterString.read(from: &buf), 
            cachedAt: FfiConverterInt64.read(from: &buf), 
            isPartial: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: User, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.avatar, into: &buf)
        FfiConverterString.write(value.publicKey, into: &buf)
        FfiConverterString.write(value.remark, into: &buf)
        FfiConverterBool.write(value.isContact, into: &buf)
        FfiConverterBool.write(value.isStar, into: &buf)
        FfiConverterBool.write(value.isBlocked, into: &buf)
        FfiConverterString.write(value.locale, into: &buf)
        FfiConverterString.write(value.city, into: &buf)
        FfiConverterString.write(value.country, into: &buf)
        FfiConverterString.write(value.source, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.gender, into: &buf)
        FfiConverterInt64.write(value.cachedAt, into: &buf)
        FfiConverterBool.write(value.isPartial, into: &buf)
    }
}


public func FfiConverterTypeUser_lift(_ buf: RustBuffer) throws -> User {
    return try FfiConverterTypeUser.lift(buf)
}

public func FfiConverterTypeUser_lower(_ value: User) -> RustBuffer {
    return FfiConverterTypeUser.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AttachmentStatus {
    
    case toUpload
    case toDownload
    case uploading
    case downloading
    case paused
    case done
    case failed
}

public struct FfiConverterTypeAttachmentStatus: FfiConverterRustBuffer {
    typealias SwiftType = AttachmentStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttachmentStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .toUpload
        
        case 2: return .toDownload
        
        case 3: return .uploading
        
        case 4: return .downloading
        
        case 5: return .paused
        
        case 6: return .done
        
        case 7: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AttachmentStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .toUpload:
            writeInt(&buf, Int32(1))
        
        
        case .toDownload:
            writeInt(&buf, Int32(2))
        
        
        case .uploading:
            writeInt(&buf, Int32(3))
        
        
        case .downloading:
            writeInt(&buf, Int32(4))
        
        
        case .paused:
            writeInt(&buf, Int32(5))
        
        
        case .done:
            writeInt(&buf, Int32(6))
        
        
        case .failed:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeAttachmentStatus_lift(_ buf: RustBuffer) throws -> AttachmentStatus {
    return try FfiConverterTypeAttachmentStatus.lift(buf)
}

public func FfiConverterTypeAttachmentStatus_lower(_ value: AttachmentStatus) -> RustBuffer {
    return FfiConverterTypeAttachmentStatus.lower(value)
}


extension AttachmentStatus: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum ChatLogStatus {
    
    case uploading
    case sending
    case sent
    case downloading
    case received
    case read
    case sendFailed
}

public struct FfiConverterTypeChatLogStatus: FfiConverterRustBuffer {
    typealias SwiftType = ChatLogStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChatLogStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .uploading
        
        case 2: return .sending
        
        case 3: return .sent
        
        case 4: return .downloading
        
        case 5: return .received
        
        case 6: return .read
        
        case 7: return .sendFailed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ChatLogStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .uploading:
            writeInt(&buf, Int32(1))
        
        
        case .sending:
            writeInt(&buf, Int32(2))
        
        
        case .sent:
            writeInt(&buf, Int32(3))
        
        
        case .downloading:
            writeInt(&buf, Int32(4))
        
        
        case .received:
            writeInt(&buf, Int32(5))
        
        
        case .read:
            writeInt(&buf, Int32(6))
        
        
        case .sendFailed:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeChatLogStatus_lift(_ buf: RustBuffer) throws -> ChatLogStatus {
    return try FfiConverterTypeChatLogStatus.lift(buf)
}

public func FfiConverterTypeChatLogStatus_lower(_ value: ChatLogStatus) -> RustBuffer {
    return FfiConverterTypeChatLogStatus.lower(value)
}


extension ChatLogStatus: Equatable, Hashable {}



public enum ClientError {

    
    
    // Simple error enums only carry a message
    case InvalidPassword(message: String)
    
    // Simple error enums only carry a message
    case Forbidden(message: String)
    
    // Simple error enums only carry a message
    case TokenExpired(message: String)
    
    // Simple error enums only carry a message
    case NetworkBroken(message: String)
    
    // Simple error enums only carry a message
    case TopicNotFound(message: String)
    
    // Simple error enums only carry a message
    case TopicKnockNotFound(message: String)
    
    // Simple error enums only carry a message
    case ChatLogNotFound(message: String)
    
    // Simple error enums only carry a message
    case InvalidContent(message: String)
    
    // Simple error enums only carry a message
    case ConversationNotFound(message: String)
    
    // Simple error enums only carry a message
    case UserNotFound(message: String)
    
    // Simple error enums only carry a message
    case KickOffByOtherClient(message: String)
    
    // Simple error enums only carry a message
    case StdError(message: String)
    
    // Simple error enums only carry a message
    case WebsocketError(message: String)
    
    // Simple error enums only carry a message
    case Http(message: String)
    
    // Simple error enums only carry a message
    case Json(message: String)
    
    // Simple error enums only carry a message
    case UserCancel(message: String)
    
    // Simple error enums only carry a message
    case Storage(message: String)
    
    // Simple error enums only carry a message
    case Other(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeClientError.lift(error)
    }
}


public struct FfiConverterTypeClientError: FfiConverterRustBuffer {
    typealias SwiftType = ClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidPassword(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Forbidden(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .TokenExpired(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .NetworkBroken(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .TopicNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .TopicKnockNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .ChatLogNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .InvalidContent(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .ConversationNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .UserNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .KickOffByOtherClient(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .StdError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .WebsocketError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 14: return .Http(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .Json(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 16: return .UserCancel(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 17: return .Storage(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 18: return .Other(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidPassword(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Forbidden(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .TokenExpired(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .NetworkBroken(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .TopicNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .TopicKnockNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .ChatLogNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .InvalidContent(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .ConversationNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .UserNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .KickOffByOtherClient(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))
        case .StdError(_ /* message is ignored*/):
            writeInt(&buf, Int32(12))
        case .WebsocketError(_ /* message is ignored*/):
            writeInt(&buf, Int32(13))
        case .Http(_ /* message is ignored*/):
            writeInt(&buf, Int32(14))
        case .Json(_ /* message is ignored*/):
            writeInt(&buf, Int32(15))
        case .UserCancel(_ /* message is ignored*/):
            writeInt(&buf, Int32(16))
        case .Storage(_ /* message is ignored*/):
            writeInt(&buf, Int32(17))
        case .Other(_ /* message is ignored*/):
            writeInt(&buf, Int32(18))

        
        }
    }
}


extension ClientError: Equatable, Hashable {}

extension ClientError: Error { }

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate typealias UniFFICallbackHandle = UInt64
fileprivate class UniFFICallbackHandleMap<T> {
    private var leftMap: [UniFFICallbackHandle: T] = [:]
    private var counter: [UniFFICallbackHandle: UInt64] = [:]
    private var rightMap: [ObjectIdentifier: UniFFICallbackHandle] = [:]

    private let lock = NSLock()
    private var currentHandle: UniFFICallbackHandle = 0
    private let stride: UniFFICallbackHandle = 1

    func insert(obj: T) -> UniFFICallbackHandle {
        lock.withLock {
            let id = ObjectIdentifier(obj as AnyObject)
            let handle = rightMap[id] ?? {
                currentHandle += stride
                let handle = currentHandle
                leftMap[handle] = obj
                rightMap[id] = handle
                return handle
            }()
            counter[handle] = (counter[handle] ?? 0) + 1
            return handle
        }
    }

    func get(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            leftMap[handle]
        }
    }

    func delete(handle: UniFFICallbackHandle) {
        remove(handle: handle)
    }

    @discardableResult
    func remove(handle: UniFFICallbackHandle) -> T? {
        lock.withLock {
            defer { counter[handle] = (counter[handle] ?? 1) - 1 }
            guard counter[handle] == 1 else { return leftMap[handle] }
            let obj = leftMap.removeValue(forKey: handle)
            if let obj = obj {
                rightMap.removeValue(forKey: ObjectIdentifier(obj as AnyObject))
            }
            return obj
        }
    }
}

// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

// Declaration and FfiConverters for Callback Callback Interface

public protocol Callback : AnyObject {
    func onConnected() 
    func onConnecting() 
    func onTokenExpired(reason: String) 
    func onNetBroken(reason: String) 
    func onKickoffByOtherClient(reason: String) 
    func onSystemRequest(req: ChatRequest)  -> ChatRequest?
    func onUnknownRequest(req: ChatRequest)  -> ChatRequest?
    func onTopicTyping(topicId: String, message: String?) 
    func onNewMessage(topicId: String, message: ChatRequest)  -> Bool
    func onTopicRead(topicId: String, message: ChatRequest) 
    func onConversationsUpdated(conversations: [Conversation]) 
    func onConversationRemoved(conversatioId: String) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnConnected(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onConnected(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnConnecting(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onConnecting(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnTokenExpired(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onTokenExpired(
                    reason:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnNetBroken(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onNetBroken(
                    reason:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnKickoffByOtherClient(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onKickoffByOtherClient(
                    reason:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnSystemRequest(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result =  swiftCallbackInterface.onSystemRequest(
                    req:  try FfiConverterTypeChatRequest.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterOptionTypeChatRequest.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnUnknownRequest(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result =  swiftCallbackInterface.onUnknownRequest(
                    req:  try FfiConverterTypeChatRequest.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterOptionTypeChatRequest.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnTopicTyping(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onTopicTyping(
                    topicId:  try FfiConverterString.read(from: &reader), 
                    message:  try FfiConverterOptionString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnNewMessage(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            let result =  swiftCallbackInterface.onNewMessage(
                    topicId:  try FfiConverterString.read(from: &reader), 
                    message:  try FfiConverterTypeChatRequest.read(from: &reader)
                    )
            var writer = [UInt8]()
            FfiConverterBool.write(result, into: &writer)
            out_buf.pointee = RustBuffer(bytes: writer)
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnTopicRead(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onTopicRead(
                    topicId:  try FfiConverterString.read(from: &reader), 
                    message:  try FfiConverterTypeChatRequest.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnConversationsUpdated(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onConversationsUpdated(
                    conversations:  try FfiConverterSequenceTypeConversation.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnConversationRemoved(_ swiftCallbackInterface: Callback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onConversationRemoved(
                    conversatioId:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceCallback.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnConnected(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnConnecting(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 3:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnTokenExpired(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 4:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnNetBroken(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 5:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnKickoffByOtherClient(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 6:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnSystemRequest(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 7:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnUnknownRequest(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 8:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnTopicTyping(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 9:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnNewMessage(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 10:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnTopicRead(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 11:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnConversationsUpdated(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 12:
            let cb: Callback
            do {
                cb = try FfiConverterCallbackInterfaceCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("Callback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnConversationRemoved(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceCallback {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_restsend_sdk_fn_init_callback_callback(foreignCallbackCallbackInterfaceCallback, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<Callback>()
}

extension FfiConverterCallbackInterfaceCallback : FfiConverter {
    typealias SwiftType = Callback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for DownloadCallback Callback Interface

public protocol DownloadCallback : AnyObject {
    func onProgress(progress: UInt64, total: UInt64) 
    func onSuccess(url: String, fileName: String) 
    func onFail(e: ClientError) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceDownloadCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnProgress(_ swiftCallbackInterface: DownloadCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onProgress(
                    progress:  try FfiConverterUInt64.read(from: &reader), 
                    total:  try FfiConverterUInt64.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnSuccess(_ swiftCallbackInterface: DownloadCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onSuccess(
                    url:  try FfiConverterString.read(from: &reader), 
                    fileName:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnFail(_ swiftCallbackInterface: DownloadCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onFail(
                    e:  try FfiConverterTypeClientError.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceDownloadCallback.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: DownloadCallback
            do {
                cb = try FfiConverterCallbackInterfaceDownloadCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("DownloadCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnProgress(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: DownloadCallback
            do {
                cb = try FfiConverterCallbackInterfaceDownloadCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("DownloadCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnSuccess(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 3:
            let cb: DownloadCallback
            do {
                cb = try FfiConverterCallbackInterfaceDownloadCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("DownloadCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnFail(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceDownloadCallback {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_restsend_sdk_fn_init_callback_downloadcallback(foreignCallbackCallbackInterfaceDownloadCallback, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<DownloadCallback>()
}

extension FfiConverterCallbackInterfaceDownloadCallback : FfiConverter {
    typealias SwiftType = DownloadCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for MessageCallback Callback Interface

public protocol MessageCallback : AnyObject {
    func onSent() 
    func onProgress(progress: UInt64, total: UInt64) 
    func onAck(req: ChatRequest) 
    func onFail(reason: String) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceMessageCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnSent(_ swiftCallbackInterface: MessageCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onSent(
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnProgress(_ swiftCallbackInterface: MessageCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onProgress(
                    progress:  try FfiConverterUInt64.read(from: &reader), 
                    total:  try FfiConverterUInt64.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnAck(_ swiftCallbackInterface: MessageCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onAck(
                    req:  try FfiConverterTypeChatRequest.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnFail(_ swiftCallbackInterface: MessageCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onFail(
                    reason:  try FfiConverterString.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceMessageCallback.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: MessageCallback
            do {
                cb = try FfiConverterCallbackInterfaceMessageCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("MessageCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnSent(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: MessageCallback
            do {
                cb = try FfiConverterCallbackInterfaceMessageCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("MessageCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnProgress(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 3:
            let cb: MessageCallback
            do {
                cb = try FfiConverterCallbackInterfaceMessageCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("MessageCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnAck(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 4:
            let cb: MessageCallback
            do {
                cb = try FfiConverterCallbackInterfaceMessageCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("MessageCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnFail(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceMessageCallback {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_restsend_sdk_fn_init_callback_messagecallback(foreignCallbackCallbackInterfaceMessageCallback, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<MessageCallback>()
}

extension FfiConverterCallbackInterfaceMessageCallback : FfiConverter {
    typealias SwiftType = MessageCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SyncChatLogsCallback Callback Interface

public protocol SyncChatLogsCallback : AnyObject {
    func onSuccess(r: GetChatLogsResult) 
    func onFail(e: ClientError) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSyncChatLogsCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnSuccess(_ swiftCallbackInterface: SyncChatLogsCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onSuccess(
                    r:  try FfiConverterTypeGetChatLogsResult.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnFail(_ swiftCallbackInterface: SyncChatLogsCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onFail(
                    e:  try FfiConverterTypeClientError.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSyncChatLogsCallback.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SyncChatLogsCallback
            do {
                cb = try FfiConverterCallbackInterfaceSyncChatLogsCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SyncChatLogsCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnSuccess(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: SyncChatLogsCallback
            do {
                cb = try FfiConverterCallbackInterfaceSyncChatLogsCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SyncChatLogsCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnFail(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSyncChatLogsCallback {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_restsend_sdk_fn_init_callback_syncchatlogscallback(foreignCallbackCallbackInterfaceSyncChatLogsCallback, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SyncChatLogsCallback>()
}

extension FfiConverterCallbackInterfaceSyncChatLogsCallback : FfiConverter {
    typealias SwiftType = SyncChatLogsCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for SyncConversationsCallback Callback Interface

public protocol SyncConversationsCallback : AnyObject {
    func onSuccess(updatedAt: String, count: UInt32) 
    func onFail(e: ClientError) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceSyncConversationsCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnSuccess(_ swiftCallbackInterface: SyncConversationsCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onSuccess(
                    updatedAt:  try FfiConverterString.read(from: &reader), 
                    count:  try FfiConverterUInt32.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnFail(_ swiftCallbackInterface: SyncConversationsCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onFail(
                    e:  try FfiConverterTypeClientError.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceSyncConversationsCallback.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: SyncConversationsCallback
            do {
                cb = try FfiConverterCallbackInterfaceSyncConversationsCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SyncConversationsCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnSuccess(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: SyncConversationsCallback
            do {
                cb = try FfiConverterCallbackInterfaceSyncConversationsCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("SyncConversationsCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnFail(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceSyncConversationsCallback {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_restsend_sdk_fn_init_callback_syncconversationscallback(foreignCallbackCallbackInterfaceSyncConversationsCallback, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<SyncConversationsCallback>()
}

extension FfiConverterCallbackInterfaceSyncConversationsCallback : FfiConverter {
    typealias SwiftType = SyncConversationsCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}



// Declaration and FfiConverters for UploadCallback Callback Interface

public protocol UploadCallback : AnyObject {
    func onProgress(progress: UInt64, total: UInt64) 
    func onSuccess(result: Upload) 
    func onFail(e: ClientError) 
    
}

// The ForeignCallback that is passed to Rust.
fileprivate let foreignCallbackCallbackInterfaceUploadCallback : ForeignCallback =
    { (handle: UniFFICallbackHandle, method: Int32, argsData: UnsafePointer<UInt8>, argsLen: Int32, out_buf: UnsafeMutablePointer<RustBuffer>) -> Int32 in
    

    func invokeOnProgress(_ swiftCallbackInterface: UploadCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onProgress(
                    progress:  try FfiConverterUInt64.read(from: &reader), 
                    total:  try FfiConverterUInt64.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnSuccess(_ swiftCallbackInterface: UploadCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onSuccess(
                    result:  try FfiConverterTypeUpload.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }

    func invokeOnFail(_ swiftCallbackInterface: UploadCallback, _ argsData: UnsafePointer<UInt8>, _ argsLen: Int32, _ out_buf: UnsafeMutablePointer<RustBuffer>) throws -> Int32 {
        var reader = createReader(data: Data(bytes: argsData, count: Int(argsLen)))
        func makeCall() throws -> Int32 {
            try swiftCallbackInterface.onFail(
                    e:  try FfiConverterTypeClientError.read(from: &reader)
                    )
            return UNIFFI_CALLBACK_SUCCESS
        }
        return try makeCall()
    }


    switch method {
        case IDX_CALLBACK_FREE:
            FfiConverterCallbackInterfaceUploadCallback.drop(handle: handle)
            // Sucessful return
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_SUCCESS
        case 1:
            let cb: UploadCallback
            do {
                cb = try FfiConverterCallbackInterfaceUploadCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("UploadCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnProgress(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 2:
            let cb: UploadCallback
            do {
                cb = try FfiConverterCallbackInterfaceUploadCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("UploadCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnSuccess(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        case 3:
            let cb: UploadCallback
            do {
                cb = try FfiConverterCallbackInterfaceUploadCallback.lift(handle)
            } catch {
                out_buf.pointee = FfiConverterString.lower("UploadCallback: Invalid handle")
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
            do {
                return try invokeOnFail(cb, argsData, argsLen, out_buf)
            } catch let error {
                out_buf.pointee = FfiConverterString.lower(String(describing: error))
                return UNIFFI_CALLBACK_UNEXPECTED_ERROR
            }
        
        // This should never happen, because an out of bounds method index won't
        // ever be used. Once we can catch errors, we should return an InternalError.
        // https://github.com/mozilla/uniffi-rs/issues/351
        default:
            // An unexpected error happened.
            // See docs of ForeignCallback in `uniffi_core/src/ffi/foreigncallbacks.rs`
            return UNIFFI_CALLBACK_UNEXPECTED_ERROR
    }
}

// FfiConverter protocol for callback interfaces
fileprivate struct FfiConverterCallbackInterfaceUploadCallback {
    private static let initCallbackOnce: () = {
        // Swift ensures this initializer code will once run once, even when accessed by multiple threads.
        try! rustCall { (err: UnsafeMutablePointer<RustCallStatus>) in
            uniffi_restsend_sdk_fn_init_callback_uploadcallback(foreignCallbackCallbackInterfaceUploadCallback, err)
        }
    }()

    private static func ensureCallbackinitialized() {
        _ = initCallbackOnce
    }

    static func drop(handle: UniFFICallbackHandle) {
        handleMap.remove(handle: handle)
    }

    private static var handleMap = UniFFICallbackHandleMap<UploadCallback>()
}

extension FfiConverterCallbackInterfaceUploadCallback : FfiConverter {
    typealias SwiftType = UploadCallback
    // We can use Handle as the FfiType because it's a typealias to UInt64
    typealias FfiType = UniFFICallbackHandle

    public static func lift(_ handle: UniFFICallbackHandle) throws -> SwiftType {
        ensureCallbackinitialized();
        guard let callback = handleMap.get(handle: handle) else {
            throw UniffiInternalError.unexpectedStaleHandle
        }
        return callback
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        ensureCallbackinitialized();
        let handle: UniFFICallbackHandle = try readInt(&buf)
        return try lift(handle)
    }

    public static func lower(_ v: SwiftType) -> UniFFICallbackHandle {
        ensureCallbackinitialized();
        return handleMap.insert(obj: v)
    }

    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        ensureCallbackinitialized();
        writeInt(&buf, lower(v))
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAttachment: FfiConverterRustBuffer {
    typealias SwiftType = Attachment?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAttachment.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAttachment.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAuthInfo: FfiConverterRustBuffer {
    typealias SwiftType = AuthInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAuthInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAuthInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeChatLog: FfiConverterRustBuffer {
    typealias SwiftType = ChatLog?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChatLog.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChatLog.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeChatRequest: FfiConverterRustBuffer {
    typealias SwiftType = ChatRequest?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeChatRequest.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeChatRequest.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeContent: FfiConverterRustBuffer {
    typealias SwiftType = Content?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeContent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeContent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeConversation: FfiConverterRustBuffer {
    typealias SwiftType = Conversation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeConversation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeConversation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeGetChatLogsResult: FfiConverterRustBuffer {
    typealias SwiftType = GetChatLogsResult?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeGetChatLogsResult.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeGetChatLogsResult.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeTopicNotice: FfiConverterRustBuffer {
    typealias SwiftType = TopicNotice?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTopicNotice.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTopicNotice.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUser: FfiConverterRustBuffer {
    typealias SwiftType = User?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUser.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUser.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceCallback: FfiConverterRustBuffer {
    typealias SwiftType = Callback?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceCallback.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceCallback.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionCallbackInterfaceMessageCallback: FfiConverterRustBuffer {
    typealias SwiftType = MessageCallback?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceMessageCallback.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceMessageCallback.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeTag: FfiConverterRustBuffer {
    typealias SwiftType = [Tag]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeTag.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeTag.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeTopicKnock: FfiConverterRustBuffer {
    typealias SwiftType = [TopicKnock]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeTopicKnock.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeTopicKnock.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeUser: FfiConverterRustBuffer {
    typealias SwiftType = [User]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeUser.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeUser.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionDictionaryStringString: FfiConverterRustBuffer {
    typealias SwiftType = [String: String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeChatLog: FfiConverterRustBuffer {
    typealias SwiftType = [ChatLog]

    public static func write(_ value: [ChatLog], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeChatLog.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ChatLog] {
        let len: Int32 = try readInt(&buf)
        var seq = [ChatLog]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeChatLog.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeConversation: FfiConverterRustBuffer {
    typealias SwiftType = [Conversation]

    public static func write(_ value: [Conversation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeConversation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Conversation] {
        let len: Int32 = try readInt(&buf)
        var seq = [Conversation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeConversation.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTag: FfiConverterRustBuffer {
    typealias SwiftType = [Tag]

    public static func write(_ value: [Tag], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTag.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Tag] {
        let len: Int32 = try readInt(&buf)
        var seq = [Tag]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTag.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeTopicKnock: FfiConverterRustBuffer {
    typealias SwiftType = [TopicKnock]

    public static func write(_ value: [TopicKnock], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTopicKnock.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TopicKnock] {
        let len: Int32 = try readInt(&buf)
        var seq = [TopicKnock]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTopicKnock.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUser: FfiConverterRustBuffer {
    typealias SwiftType = [User]

    public static func write(_ value: [User], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUser.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [User] {
        let len: Int32 = try readInt(&buf)
        var seq = [User]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUser.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}
private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UnsafeMutableRawPointer,
    pollFunc: (UnsafeMutableRawPointer, UnsafeMutableRawPointer) -> (),
    completeFunc: (UnsafeMutableRawPointer, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UnsafeMutableRawPointer) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(rustFuture, ContinuationHolder($0).toOpaque())
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(ptr: UnsafeMutableRawPointer, pollResult: Int8) {
    ContinuationHolder.fromOpaque(ptr).resume(pollResult)
}

// Wraps UnsafeContinuation in a class so that we can use reference counting when passing it across
// the FFI
fileprivate class ContinuationHolder {
    let continuation: UnsafeContinuation<Int8, Never>

    init(_ continuation: UnsafeContinuation<Int8, Never>) {
        self.continuation = continuation
    }

    func resume(_ pollResult: Int8) {
        self.continuation.resume(returning: pollResult)
    }

    func toOpaque() -> UnsafeMutableRawPointer {
        return Unmanaged<ContinuationHolder>.passRetained(self).toOpaque()
    }

    static func fromOpaque(_ ptr: UnsafeRawPointer) -> ContinuationHolder {
        return Unmanaged<ContinuationHolder>.fromOpaque(ptr).takeRetainedValue()
    }
}

fileprivate func uniffiInitContinuationCallback() {
    ffi_restsend_sdk_rust_future_continuation_callback_set(uniffiFutureContinuationCallback)
}

public func attachmentFromLocal(fileName: String, filePath: String, isPrivate: Bool)  -> Attachment {
    return try!  FfiConverterTypeAttachment.lift(
        try! rustCall() {
    uniffi_restsend_sdk_fn_func_attachment_from_local(
        FfiConverterString.lower(fileName),
        FfiConverterString.lower(filePath),
        FfiConverterBool.lower(isPrivate),$0)
}
    )
}

public func attachmentFromUrl(url: String, isPrivate: Bool, size: Int64)  -> Attachment {
    return try!  FfiConverterTypeAttachment.lift(
        try! rustCall() {
    uniffi_restsend_sdk_fn_func_attachment_from_url(
        FfiConverterString.lower(url),
        FfiConverterBool.lower(isPrivate),
        FfiConverterInt64.lower(size),$0)
}
    )
}

public func getCurrentUser(root: String)  -> AuthInfo? {
    return try!  FfiConverterOptionTypeAuthInfo.lift(
        try! rustCall() {
    uniffi_restsend_sdk_fn_func_get_current_user(
        FfiConverterString.lower(root),$0)
}
    )
}

public func initLog(level: String, isTest: Bool)  {
    try! rustCall() {
    uniffi_restsend_sdk_fn_func_init_log(
        FfiConverterString.lower(level),
        FfiConverterBool.lower(isTest),$0)
}
}



public func loginWithPassword(endpoint: String, email: String, password: String) async throws -> AuthInfo {
    return try  await uniffiRustCallAsync(
        rustFutureFunc: {
            uniffi_restsend_sdk_fn_func_login_with_password(
                FfiConverterString.lower(endpoint),
                FfiConverterString.lower(email),
                FfiConverterString.lower(password)
            )
        },
        pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
        completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
        freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
        liftFunc: FfiConverterTypeAuthInfo.lift,
        errorHandler: FfiConverterTypeClientError.lift
    )
}



public func loginWithToken(endpoint: String, email: String, token: String) async throws -> AuthInfo {
    return try  await uniffiRustCallAsync(
        rustFutureFunc: {
            uniffi_restsend_sdk_fn_func_login_with_token(
                FfiConverterString.lower(endpoint),
                FfiConverterString.lower(email),
                FfiConverterString.lower(token)
            )
        },
        pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
        completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
        freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
        liftFunc: FfiConverterTypeAuthInfo.lift,
        errorHandler: FfiConverterTypeClientError.lift
    )
}



public func logout(endpoint: String, token: String) async throws {
    return try  await uniffiRustCallAsync(
        rustFutureFunc: {
            uniffi_restsend_sdk_fn_func_logout(
                FfiConverterString.lower(endpoint),
                FfiConverterString.lower(token)
            )
        },
        pollFunc: ffi_restsend_sdk_rust_future_poll_void,
        completeFunc: ffi_restsend_sdk_rust_future_complete_void,
        freeFunc: ffi_restsend_sdk_rust_future_free_void,
        liftFunc: { $0 },
        errorHandler: FfiConverterTypeClientError.lift
    )
}



public func setCurrentUser(root: String, userId: String) throws {
    try rustCallWithError(FfiConverterTypeClientError.lift) {
    uniffi_restsend_sdk_fn_func_set_current_user(
        FfiConverterString.lower(root),
        FfiConverterString.lower(userId),$0)
}
}



public func signup(endpoint: String, email: String, password: String) async throws -> AuthInfo {
    return try  await uniffiRustCallAsync(
        rustFutureFunc: {
            uniffi_restsend_sdk_fn_func_signup(
                FfiConverterString.lower(endpoint),
                FfiConverterString.lower(email),
                FfiConverterString.lower(password)
            )
        },
        pollFunc: ffi_restsend_sdk_rust_future_poll_rust_buffer,
        completeFunc: ffi_restsend_sdk_rust_future_complete_rust_buffer,
        freeFunc: ffi_restsend_sdk_rust_future_free_rust_buffer,
        liftFunc: FfiConverterTypeAuthInfo.lift,
        errorHandler: FfiConverterTypeClientError.lift
    )
}



private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 24
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_restsend_sdk_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_attachment_from_local() != 11711) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_attachment_from_url() != 49991) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_get_current_user() != 58851) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_init_log() != 64963) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_login_with_password() != 63687) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_login_with_token() != 38409) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_logout() != 45700) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_set_current_user() != 58805) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_func_signup() != 45825) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_accept_topic_join() != 28191) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_add_topic_admin() != 42268) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_add_topic_member() != 19524) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_app_active() != 64583) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_app_deactivate() != 38633) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_cancel_send() != 8585) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_clean_messages() != 4149) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_connect() != 55568) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_connection_status() != 48399) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_create_chat() != 29897) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_create_topic() != 39356) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_decline_topic_join() != 51375) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_dismiss_topic() != 52118) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_read() != 31618) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_recall() != 15675) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send() != 61877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_file() != 20746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_image() != 15606) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_invite() != 12145) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_link() != 5843) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_location() != 9410) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_logs() != 15230) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_text() != 2911) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_video() != 6926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_send_voice() != 7256) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_do_typing() != 56138) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_download_file() != 56679) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_chat_log() != 63138) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_conversation() != 18135) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_topic() != 627) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_topic_admins() != 61168) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_topic_knocks() != 45295) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_topic_members() != 47693) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_topic_owner() != 43460) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_user() != 33462) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_get_users() != 63546) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_join_topic() != 19230) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_quit_topic() != 56845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_remove_conversation() != 21191) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_remove_messages() != 62944) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_remove_topic_admin() != 11254) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_remove_topic_member() != 24125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_search_chat_log() != 20467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_send_chat_request() != 7543) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_send_chat_request_via_connection() != 19356) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_allow_guest_chat() != 18959) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_callback() != 27441) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_conversation_extra() != 64023) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_conversation_mute() != 46412) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_conversation_read() != 45318) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_conversation_remark() != 50416) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_conversation_sticky() != 7467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_conversation_tags() != 9878) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_user_block() != 7357) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_user_remark() != 5359) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_set_user_star() != 33643) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_shutdown() != 8972) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_silent_topic() != 43972) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_silent_topic_member() != 11552) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_sync_chat_logs() != 51862) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_sync_conversations() != 27599) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_transfer_topic() != 50298) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_update_topic() != 39010) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_client_update_topic_notice() != 46034) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_constructor_client_new() != 22403) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_callback_on_connected() != 30102) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_callback_on_connecting() != 54577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_callback_on_token_expired() != 48317) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_callback_on_net_broken() != 59575) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_callback_on_kickoff_by_other_client() != 29418) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_callback_on_system_request() != 42590) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_callback_on_unknown_request() != 37449) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_callback_on_topic_typing() != 36417) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_callback_on_new_message() != 43941) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_callback_on_topic_read() != 55560) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_callback_on_conversations_updated() != 37269) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_callback_on_conversation_removed() != 6271) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_downloadcallback_on_progress() != 20970) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_downloadcallback_on_success() != 31767) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_downloadcallback_on_fail() != 47134) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_messagecallback_on_sent() != 61950) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_messagecallback_on_progress() != 6454) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_messagecallback_on_ack() != 23621) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_messagecallback_on_fail() != 64032) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_syncchatlogscallback_on_success() != 44636) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_syncchatlogscallback_on_fail() != 48821) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_syncconversationscallback_on_success() != 5994) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_syncconversationscallback_on_fail() != 50976) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_uploadcallback_on_progress() != 44240) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_uploadcallback_on_success() != 47867) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_restsend_sdk_checksum_method_uploadcallback_on_fail() != 63924) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiInitContinuationCallback()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}