// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(restsend_sdkFFI)
import restsend_sdkFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_restsend_sdk_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_restsend_sdk_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_PANIC: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_PANIC:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
                throw CancellationError()

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.


fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}


public struct Attachment {
    public var thumbnail: String
    public var fileName: String
    public var filePath: String
    public var urlOrData: String
    public var isPrivate: Bool
    public var status: AttachmentStatus

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(thumbnail: String, fileName: String, filePath: String, urlOrData: String, isPrivate: Bool, status: AttachmentStatus) {
        self.thumbnail = thumbnail
        self.fileName = fileName
        self.filePath = filePath
        self.urlOrData = urlOrData
        self.isPrivate = isPrivate
        self.status = status
    }
}


extension Attachment: Equatable, Hashable {
    public static func ==(lhs: Attachment, rhs: Attachment) -> Bool {
        if lhs.thumbnail != rhs.thumbnail {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        if lhs.filePath != rhs.filePath {
            return false
        }
        if lhs.urlOrData != rhs.urlOrData {
            return false
        }
        if lhs.isPrivate != rhs.isPrivate {
            return false
        }
        if lhs.status != rhs.status {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(thumbnail)
        hasher.combine(fileName)
        hasher.combine(filePath)
        hasher.combine(urlOrData)
        hasher.combine(isPrivate)
        hasher.combine(status)
    }
}


public struct FfiConverterTypeAttachment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Attachment {
        return try Attachment(
            thumbnail: FfiConverterString.read(from: &buf), 
            fileName: FfiConverterString.read(from: &buf), 
            filePath: FfiConverterString.read(from: &buf), 
            urlOrData: FfiConverterString.read(from: &buf), 
            isPrivate: FfiConverterBool.read(from: &buf), 
            status: FfiConverterTypeAttachmentStatus.read(from: &buf)
        )
    }

    public static func write(_ value: Attachment, into buf: inout [UInt8]) {
        FfiConverterString.write(value.thumbnail, into: &buf)
        FfiConverterString.write(value.fileName, into: &buf)
        FfiConverterString.write(value.filePath, into: &buf)
        FfiConverterString.write(value.urlOrData, into: &buf)
        FfiConverterBool.write(value.isPrivate, into: &buf)
        FfiConverterTypeAttachmentStatus.write(value.status, into: &buf)
    }
}


public func FfiConverterTypeAttachment_lift(_ buf: RustBuffer) throws -> Attachment {
    return try FfiConverterTypeAttachment.lift(buf)
}

public func FfiConverterTypeAttachment_lower(_ value: Attachment) -> RustBuffer {
    return FfiConverterTypeAttachment.lower(value)
}


public struct AuthInfo {
    public var endpoint: String
    public var userId: String
    public var avatar: String
    public var name: String
    public var token: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(endpoint: String, userId: String, avatar: String, name: String, token: String) {
        self.endpoint = endpoint
        self.userId = userId
        self.avatar = avatar
        self.name = name
        self.token = token
    }
}


extension AuthInfo: Equatable, Hashable {
    public static func ==(lhs: AuthInfo, rhs: AuthInfo) -> Bool {
        if lhs.endpoint != rhs.endpoint {
            return false
        }
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.avatar != rhs.avatar {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.token != rhs.token {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(endpoint)
        hasher.combine(userId)
        hasher.combine(avatar)
        hasher.combine(name)
        hasher.combine(token)
    }
}


public struct FfiConverterTypeAuthInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthInfo {
        return try AuthInfo(
            endpoint: FfiConverterString.read(from: &buf), 
            userId: FfiConverterString.read(from: &buf), 
            avatar: FfiConverterString.read(from: &buf), 
            name: FfiConverterString.read(from: &buf), 
            token: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AuthInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.endpoint, into: &buf)
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.avatar, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.token, into: &buf)
    }
}


public func FfiConverterTypeAuthInfo_lift(_ buf: RustBuffer) throws -> AuthInfo {
    return try FfiConverterTypeAuthInfo.lift(buf)
}

public func FfiConverterTypeAuthInfo_lower(_ value: AuthInfo) -> RustBuffer {
    return FfiConverterTypeAuthInfo.lower(value)
}


public struct ChatRequest {
    public var type: String
    public var id: String
    public var code: UInt32
    public var topicId: String
    public var seq: Int64
    public var attendee: String
    public var attendeeProfile: User?
    public var chatId: String
    public var createdAt: String
    public var content: Content?
    public var e2eContent: String?
    public var message: String?
    public var source: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(type: String, id: String, code: UInt32, topicId: String, seq: Int64, attendee: String, attendeeProfile: User?, chatId: String, createdAt: String, content: Content?, e2eContent: String?, message: String?, source: String?) {
        self.type = type
        self.id = id
        self.code = code
        self.topicId = topicId
        self.seq = seq
        self.attendee = attendee
        self.attendeeProfile = attendeeProfile
        self.chatId = chatId
        self.createdAt = createdAt
        self.content = content
        self.e2eContent = e2eContent
        self.message = message
        self.source = source
    }
}


extension ChatRequest: Equatable, Hashable {
    public static func ==(lhs: ChatRequest, rhs: ChatRequest) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        if lhs.id != rhs.id {
            return false
        }
        if lhs.code != rhs.code {
            return false
        }
        if lhs.topicId != rhs.topicId {
            return false
        }
        if lhs.seq != rhs.seq {
            return false
        }
        if lhs.attendee != rhs.attendee {
            return false
        }
        if lhs.attendeeProfile != rhs.attendeeProfile {
            return false
        }
        if lhs.chatId != rhs.chatId {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.content != rhs.content {
            return false
        }
        if lhs.e2eContent != rhs.e2eContent {
            return false
        }
        if lhs.message != rhs.message {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
        hasher.combine(id)
        hasher.combine(code)
        hasher.combine(topicId)
        hasher.combine(seq)
        hasher.combine(attendee)
        hasher.combine(attendeeProfile)
        hasher.combine(chatId)
        hasher.combine(createdAt)
        hasher.combine(content)
        hasher.combine(e2eContent)
        hasher.combine(message)
        hasher.combine(source)
    }
}


public struct FfiConverterTypeChatRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ChatRequest {
        return try ChatRequest(
            type: FfiConverterString.read(from: &buf), 
            id: FfiConverterString.read(from: &buf), 
            code: FfiConverterUInt32.read(from: &buf), 
            topicId: FfiConverterString.read(from: &buf), 
            seq: FfiConverterInt64.read(from: &buf), 
            attendee: FfiConverterString.read(from: &buf), 
            attendeeProfile: FfiConverterOptionTypeUser.read(from: &buf), 
            chatId: FfiConverterString.read(from: &buf), 
            createdAt: FfiConverterString.read(from: &buf), 
            content: FfiConverterOptionTypeContent.read(from: &buf), 
            e2eContent: FfiConverterOptionString.read(from: &buf), 
            message: FfiConverterOptionString.read(from: &buf), 
            source: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ChatRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.type, into: &buf)
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterUInt32.write(value.code, into: &buf)
        FfiConverterString.write(value.topicId, into: &buf)
        FfiConverterInt64.write(value.seq, into: &buf)
        FfiConverterString.write(value.attendee, into: &buf)
        FfiConverterOptionTypeUser.write(value.attendeeProfile, into: &buf)
        FfiConverterString.write(value.chatId, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterOptionTypeContent.write(value.content, into: &buf)
        FfiConverterOptionString.write(value.e2eContent, into: &buf)
        FfiConverterOptionString.write(value.message, into: &buf)
        FfiConverterOptionString.write(value.source, into: &buf)
    }
}


public func FfiConverterTypeChatRequest_lift(_ buf: RustBuffer) throws -> ChatRequest {
    return try FfiConverterTypeChatRequest.lift(buf)
}

public func FfiConverterTypeChatRequest_lower(_ value: ChatRequest) -> RustBuffer {
    return FfiConverterTypeChatRequest.lower(value)
}


public struct Content {
    public var type: String
    public var encrypted: Bool
    public var checksum: UInt32
    public var text: String
    public var placeholder: String
    public var thumbnail: String
    public var duration: String
    public var size: UInt64
    public var width: Float
    public var height: Float
    public var mentions: [String]
    public var reply: String
    public var createdAt: String
    public var attachment: Attachment?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(type: String, encrypted: Bool, checksum: UInt32, text: String, placeholder: String, thumbnail: String, duration: String, size: UInt64, width: Float, height: Float, mentions: [String], reply: String, createdAt: String, attachment: Attachment?) {
        self.type = type
        self.encrypted = encrypted
        self.checksum = checksum
        self.text = text
        self.placeholder = placeholder
        self.thumbnail = thumbnail
        self.duration = duration
        self.size = size
        self.width = width
        self.height = height
        self.mentions = mentions
        self.reply = reply
        self.createdAt = createdAt
        self.attachment = attachment
    }
}


extension Content: Equatable, Hashable {
    public static func ==(lhs: Content, rhs: Content) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        if lhs.encrypted != rhs.encrypted {
            return false
        }
        if lhs.checksum != rhs.checksum {
            return false
        }
        if lhs.text != rhs.text {
            return false
        }
        if lhs.placeholder != rhs.placeholder {
            return false
        }
        if lhs.thumbnail != rhs.thumbnail {
            return false
        }
        if lhs.duration != rhs.duration {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.width != rhs.width {
            return false
        }
        if lhs.height != rhs.height {
            return false
        }
        if lhs.mentions != rhs.mentions {
            return false
        }
        if lhs.reply != rhs.reply {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.attachment != rhs.attachment {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
        hasher.combine(encrypted)
        hasher.combine(checksum)
        hasher.combine(text)
        hasher.combine(placeholder)
        hasher.combine(thumbnail)
        hasher.combine(duration)
        hasher.combine(size)
        hasher.combine(width)
        hasher.combine(height)
        hasher.combine(mentions)
        hasher.combine(reply)
        hasher.combine(createdAt)
        hasher.combine(attachment)
    }
}


public struct FfiConverterTypeContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Content {
        return try Content(
            type: FfiConverterString.read(from: &buf), 
            encrypted: FfiConverterBool.read(from: &buf), 
            checksum: FfiConverterUInt32.read(from: &buf), 
            text: FfiConverterString.read(from: &buf), 
            placeholder: FfiConverterString.read(from: &buf), 
            thumbnail: FfiConverterString.read(from: &buf), 
            duration: FfiConverterString.read(from: &buf), 
            size: FfiConverterUInt64.read(from: &buf), 
            width: FfiConverterFloat.read(from: &buf), 
            height: FfiConverterFloat.read(from: &buf), 
            mentions: FfiConverterSequenceString.read(from: &buf), 
            reply: FfiConverterString.read(from: &buf), 
            createdAt: FfiConverterString.read(from: &buf), 
            attachment: FfiConverterOptionTypeAttachment.read(from: &buf)
        )
    }

    public static func write(_ value: Content, into buf: inout [UInt8]) {
        FfiConverterString.write(value.type, into: &buf)
        FfiConverterBool.write(value.encrypted, into: &buf)
        FfiConverterUInt32.write(value.checksum, into: &buf)
        FfiConverterString.write(value.text, into: &buf)
        FfiConverterString.write(value.placeholder, into: &buf)
        FfiConverterString.write(value.thumbnail, into: &buf)
        FfiConverterString.write(value.duration, into: &buf)
        FfiConverterUInt64.write(value.size, into: &buf)
        FfiConverterFloat.write(value.width, into: &buf)
        FfiConverterFloat.write(value.height, into: &buf)
        FfiConverterSequenceString.write(value.mentions, into: &buf)
        FfiConverterString.write(value.reply, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterOptionTypeAttachment.write(value.attachment, into: &buf)
    }
}


public func FfiConverterTypeContent_lift(_ buf: RustBuffer) throws -> Content {
    return try FfiConverterTypeContent.lift(buf)
}

public func FfiConverterTypeContent_lower(_ value: Content) -> RustBuffer {
    return FfiConverterTypeContent.lower(value)
}


public struct Conversation {
    public var ownerId: String
    public var topicId: String
    public var updatedAt: String
    public var lastSeq: Int64
    public var lastReadSeq: Int64
    public var multiple: Bool
    public var attendee: String
    public var name: String
    public var icon: String
    public var sticky: Bool
    public var mute: Bool
    public var source: String
    public var unread: Int64
    public var lastSenderId: String
    public var lastMessage: Content?
    public var lastMessageAt: String
    public var cachedAt: Int64
    public var isPartial: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(ownerId: String, topicId: String, updatedAt: String, lastSeq: Int64, lastReadSeq: Int64, multiple: Bool, attendee: String, name: String, icon: String, sticky: Bool, mute: Bool, source: String, unread: Int64, lastSenderId: String, lastMessage: Content?, lastMessageAt: String, cachedAt: Int64, isPartial: Bool) {
        self.ownerId = ownerId
        self.topicId = topicId
        self.updatedAt = updatedAt
        self.lastSeq = lastSeq
        self.lastReadSeq = lastReadSeq
        self.multiple = multiple
        self.attendee = attendee
        self.name = name
        self.icon = icon
        self.sticky = sticky
        self.mute = mute
        self.source = source
        self.unread = unread
        self.lastSenderId = lastSenderId
        self.lastMessage = lastMessage
        self.lastMessageAt = lastMessageAt
        self.cachedAt = cachedAt
        self.isPartial = isPartial
    }
}


extension Conversation: Equatable, Hashable {
    public static func ==(lhs: Conversation, rhs: Conversation) -> Bool {
        if lhs.ownerId != rhs.ownerId {
            return false
        }
        if lhs.topicId != rhs.topicId {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.lastSeq != rhs.lastSeq {
            return false
        }
        if lhs.lastReadSeq != rhs.lastReadSeq {
            return false
        }
        if lhs.multiple != rhs.multiple {
            return false
        }
        if lhs.attendee != rhs.attendee {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.icon != rhs.icon {
            return false
        }
        if lhs.sticky != rhs.sticky {
            return false
        }
        if lhs.mute != rhs.mute {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.unread != rhs.unread {
            return false
        }
        if lhs.lastSenderId != rhs.lastSenderId {
            return false
        }
        if lhs.lastMessage != rhs.lastMessage {
            return false
        }
        if lhs.lastMessageAt != rhs.lastMessageAt {
            return false
        }
        if lhs.cachedAt != rhs.cachedAt {
            return false
        }
        if lhs.isPartial != rhs.isPartial {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(ownerId)
        hasher.combine(topicId)
        hasher.combine(updatedAt)
        hasher.combine(lastSeq)
        hasher.combine(lastReadSeq)
        hasher.combine(multiple)
        hasher.combine(attendee)
        hasher.combine(name)
        hasher.combine(icon)
        hasher.combine(sticky)
        hasher.combine(mute)
        hasher.combine(source)
        hasher.combine(unread)
        hasher.combine(lastSenderId)
        hasher.combine(lastMessage)
        hasher.combine(lastMessageAt)
        hasher.combine(cachedAt)
        hasher.combine(isPartial)
    }
}


public struct FfiConverterTypeConversation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Conversation {
        return try Conversation(
            ownerId: FfiConverterString.read(from: &buf), 
            topicId: FfiConverterString.read(from: &buf), 
            updatedAt: FfiConverterString.read(from: &buf), 
            lastSeq: FfiConverterInt64.read(from: &buf), 
            lastReadSeq: FfiConverterInt64.read(from: &buf), 
            multiple: FfiConverterBool.read(from: &buf), 
            attendee: FfiConverterString.read(from: &buf), 
            name: FfiConverterString.read(from: &buf), 
            icon: FfiConverterString.read(from: &buf), 
            sticky: FfiConverterBool.read(from: &buf), 
            mute: FfiConverterBool.read(from: &buf), 
            source: FfiConverterString.read(from: &buf), 
            unread: FfiConverterInt64.read(from: &buf), 
            lastSenderId: FfiConverterString.read(from: &buf), 
            lastMessage: FfiConverterOptionTypeContent.read(from: &buf), 
            lastMessageAt: FfiConverterString.read(from: &buf), 
            cachedAt: FfiConverterInt64.read(from: &buf), 
            isPartial: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Conversation, into buf: inout [UInt8]) {
        FfiConverterString.write(value.ownerId, into: &buf)
        FfiConverterString.write(value.topicId, into: &buf)
        FfiConverterString.write(value.updatedAt, into: &buf)
        FfiConverterInt64.write(value.lastSeq, into: &buf)
        FfiConverterInt64.write(value.lastReadSeq, into: &buf)
        FfiConverterBool.write(value.multiple, into: &buf)
        FfiConverterString.write(value.attendee, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.icon, into: &buf)
        FfiConverterBool.write(value.sticky, into: &buf)
        FfiConverterBool.write(value.mute, into: &buf)
        FfiConverterString.write(value.source, into: &buf)
        FfiConverterInt64.write(value.unread, into: &buf)
        FfiConverterString.write(value.lastSenderId, into: &buf)
        FfiConverterOptionTypeContent.write(value.lastMessage, into: &buf)
        FfiConverterString.write(value.lastMessageAt, into: &buf)
        FfiConverterInt64.write(value.cachedAt, into: &buf)
        FfiConverterBool.write(value.isPartial, into: &buf)
    }
}


public func FfiConverterTypeConversation_lift(_ buf: RustBuffer) throws -> Conversation {
    return try FfiConverterTypeConversation.lift(buf)
}

public func FfiConverterTypeConversation_lower(_ value: Conversation) -> RustBuffer {
    return FfiConverterTypeConversation.lower(value)
}


public struct GetConversationsResult {
    public var updatedAt: String
    public var items: [Conversation]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(updatedAt: String, items: [Conversation]) {
        self.updatedAt = updatedAt
        self.items = items
    }
}


extension GetConversationsResult: Equatable, Hashable {
    public static func ==(lhs: GetConversationsResult, rhs: GetConversationsResult) -> Bool {
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        if lhs.items != rhs.items {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(updatedAt)
        hasher.combine(items)
    }
}


public struct FfiConverterTypeGetConversationsResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GetConversationsResult {
        return try GetConversationsResult(
            updatedAt: FfiConverterString.read(from: &buf), 
            items: FfiConverterSequenceTypeConversation.read(from: &buf)
        )
    }

    public static func write(_ value: GetConversationsResult, into buf: inout [UInt8]) {
        FfiConverterString.write(value.updatedAt, into: &buf)
        FfiConverterSequenceTypeConversation.write(value.items, into: &buf)
    }
}


public func FfiConverterTypeGetConversationsResult_lift(_ buf: RustBuffer) throws -> GetConversationsResult {
    return try FfiConverterTypeGetConversationsResult.lift(buf)
}

public func FfiConverterTypeGetConversationsResult_lower(_ value: GetConversationsResult) -> RustBuffer {
    return FfiConverterTypeGetConversationsResult.lower(value)
}


public struct TopicNotice {
    public var text: String
    public var publisher: String
    public var updatedAt: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(text: String, publisher: String, updatedAt: String) {
        self.text = text
        self.publisher = publisher
        self.updatedAt = updatedAt
    }
}


extension TopicNotice: Equatable, Hashable {
    public static func ==(lhs: TopicNotice, rhs: TopicNotice) -> Bool {
        if lhs.text != rhs.text {
            return false
        }
        if lhs.publisher != rhs.publisher {
            return false
        }
        if lhs.updatedAt != rhs.updatedAt {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(text)
        hasher.combine(publisher)
        hasher.combine(updatedAt)
    }
}


public struct FfiConverterTypeTopicNotice: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TopicNotice {
        return try TopicNotice(
            text: FfiConverterString.read(from: &buf), 
            publisher: FfiConverterString.read(from: &buf), 
            updatedAt: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TopicNotice, into buf: inout [UInt8]) {
        FfiConverterString.write(value.text, into: &buf)
        FfiConverterString.write(value.publisher, into: &buf)
        FfiConverterString.write(value.updatedAt, into: &buf)
    }
}


public func FfiConverterTypeTopicNotice_lift(_ buf: RustBuffer) throws -> TopicNotice {
    return try FfiConverterTypeTopicNotice.lift(buf)
}

public func FfiConverterTypeTopicNotice_lower(_ value: TopicNotice) -> RustBuffer {
    return FfiConverterTypeTopicNotice.lower(value)
}


public struct User {
    public var userId: String
    public var name: String
    public var avatar: String
    public var publicKey: String
    public var remark: String
    public var isContact: Bool
    public var isStar: Bool
    public var isBlocked: Bool
    public var locale: String
    public var city: String
    public var country: String
    public var source: String
    public var createdAt: String
    public var gender: String
    public var cachedAt: Int64
    public var isPartial: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userId: String, name: String, avatar: String, publicKey: String, remark: String, isContact: Bool, isStar: Bool, isBlocked: Bool, locale: String, city: String, country: String, source: String, createdAt: String, gender: String, cachedAt: Int64, isPartial: Bool) {
        self.userId = userId
        self.name = name
        self.avatar = avatar
        self.publicKey = publicKey
        self.remark = remark
        self.isContact = isContact
        self.isStar = isStar
        self.isBlocked = isBlocked
        self.locale = locale
        self.city = city
        self.country = country
        self.source = source
        self.createdAt = createdAt
        self.gender = gender
        self.cachedAt = cachedAt
        self.isPartial = isPartial
    }
}


extension User: Equatable, Hashable {
    public static func ==(lhs: User, rhs: User) -> Bool {
        if lhs.userId != rhs.userId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.avatar != rhs.avatar {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.remark != rhs.remark {
            return false
        }
        if lhs.isContact != rhs.isContact {
            return false
        }
        if lhs.isStar != rhs.isStar {
            return false
        }
        if lhs.isBlocked != rhs.isBlocked {
            return false
        }
        if lhs.locale != rhs.locale {
            return false
        }
        if lhs.city != rhs.city {
            return false
        }
        if lhs.country != rhs.country {
            return false
        }
        if lhs.source != rhs.source {
            return false
        }
        if lhs.createdAt != rhs.createdAt {
            return false
        }
        if lhs.gender != rhs.gender {
            return false
        }
        if lhs.cachedAt != rhs.cachedAt {
            return false
        }
        if lhs.isPartial != rhs.isPartial {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userId)
        hasher.combine(name)
        hasher.combine(avatar)
        hasher.combine(publicKey)
        hasher.combine(remark)
        hasher.combine(isContact)
        hasher.combine(isStar)
        hasher.combine(isBlocked)
        hasher.combine(locale)
        hasher.combine(city)
        hasher.combine(country)
        hasher.combine(source)
        hasher.combine(createdAt)
        hasher.combine(gender)
        hasher.combine(cachedAt)
        hasher.combine(isPartial)
    }
}


public struct FfiConverterTypeUser: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> User {
        return try User(
            userId: FfiConverterString.read(from: &buf), 
            name: FfiConverterString.read(from: &buf), 
            avatar: FfiConverterString.read(from: &buf), 
            publicKey: FfiConverterString.read(from: &buf), 
            remark: FfiConverterString.read(from: &buf), 
            isContact: FfiConverterBool.read(from: &buf), 
            isStar: FfiConverterBool.read(from: &buf), 
            isBlocked: FfiConverterBool.read(from: &buf), 
            locale: FfiConverterString.read(from: &buf), 
            city: FfiConverterString.read(from: &buf), 
            country: FfiConverterString.read(from: &buf), 
            source: FfiConverterString.read(from: &buf), 
            createdAt: FfiConverterString.read(from: &buf), 
            gender: FfiConverterString.read(from: &buf), 
            cachedAt: FfiConverterInt64.read(from: &buf), 
            isPartial: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: User, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.avatar, into: &buf)
        FfiConverterString.write(value.publicKey, into: &buf)
        FfiConverterString.write(value.remark, into: &buf)
        FfiConverterBool.write(value.isContact, into: &buf)
        FfiConverterBool.write(value.isStar, into: &buf)
        FfiConverterBool.write(value.isBlocked, into: &buf)
        FfiConverterString.write(value.locale, into: &buf)
        FfiConverterString.write(value.city, into: &buf)
        FfiConverterString.write(value.country, into: &buf)
        FfiConverterString.write(value.source, into: &buf)
        FfiConverterString.write(value.createdAt, into: &buf)
        FfiConverterString.write(value.gender, into: &buf)
        FfiConverterInt64.write(value.cachedAt, into: &buf)
        FfiConverterBool.write(value.isPartial, into: &buf)
    }
}


public func FfiConverterTypeUser_lift(_ buf: RustBuffer) throws -> User {
    return try FfiConverterTypeUser.lift(buf)
}

public func FfiConverterTypeUser_lower(_ value: User) -> RustBuffer {
    return FfiConverterTypeUser.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AttachmentStatus {
    
    case toUpload
    case toDownload
    case uploading
    case downloading
    case paused
    case done
    case failed
}

public struct FfiConverterTypeAttachmentStatus: FfiConverterRustBuffer {
    typealias SwiftType = AttachmentStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttachmentStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .toUpload
        
        case 2: return .toDownload
        
        case 3: return .uploading
        
        case 4: return .downloading
        
        case 5: return .paused
        
        case 6: return .done
        
        case 7: return .failed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AttachmentStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case .toUpload:
            writeInt(&buf, Int32(1))
        
        
        case .toDownload:
            writeInt(&buf, Int32(2))
        
        
        case .uploading:
            writeInt(&buf, Int32(3))
        
        
        case .downloading:
            writeInt(&buf, Int32(4))
        
        
        case .paused:
            writeInt(&buf, Int32(5))
        
        
        case .done:
            writeInt(&buf, Int32(6))
        
        
        case .failed:
            writeInt(&buf, Int32(7))
        
        }
    }
}


public func FfiConverterTypeAttachmentStatus_lift(_ buf: RustBuffer) throws -> AttachmentStatus {
    return try FfiConverterTypeAttachmentStatus.lift(buf)
}

public func FfiConverterTypeAttachmentStatus_lower(_ value: AttachmentStatus) -> RustBuffer {
    return FfiConverterTypeAttachmentStatus.lower(value)
}


extension AttachmentStatus: Equatable, Hashable {}



public enum ClientError {

    
    
    // Simple error enums only carry a message
    case InvalidPassword(message: String)
    
    // Simple error enums only carry a message
    case Forbidden(message: String)
    
    // Simple error enums only carry a message
    case TokenExpired(message: String)
    
    // Simple error enums only carry a message
    case NetworkBroken(message: String)
    
    // Simple error enums only carry a message
    case TopicNotFound(message: String)
    
    // Simple error enums only carry a message
    case TopicKnockNotFound(message: String)
    
    // Simple error enums only carry a message
    case ChatLogNotFound(message: String)
    
    // Simple error enums only carry a message
    case InvalidContent(message: String)
    
    // Simple error enums only carry a message
    case ConversationNotFound(message: String)
    
    // Simple error enums only carry a message
    case UserNotFound(message: String)
    
    // Simple error enums only carry a message
    case KickOffByOtherClient(message: String)
    
    // Simple error enums only carry a message
    case StdError(message: String)
    
    // Simple error enums only carry a message
    case WebsocketError(message: String)
    
    // Simple error enums only carry a message
    case Http(message: String)
    
    // Simple error enums only carry a message
    case Json(message: String)
    
    // Simple error enums only carry a message
    case UserCancel(message: String)
    
    // Simple error enums only carry a message
    case Storage(message: String)
    
    // Simple error enums only carry a message
    case Other(message: String)
    

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeClientError.lift(error)
    }
}


public struct FfiConverterTypeClientError: FfiConverterRustBuffer {
    typealias SwiftType = ClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidPassword(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Forbidden(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .TokenExpired(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .NetworkBroken(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .TopicNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .TopicKnockNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .ChatLogNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .InvalidContent(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .ConversationNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .UserNotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .KickOffByOtherClient(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 12: return .StdError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 13: return .WebsocketError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 14: return .Http(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .Json(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 16: return .UserCancel(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 17: return .Storage(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 18: return .Other(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidPassword(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Forbidden(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .TokenExpired(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .NetworkBroken(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .TopicNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .TopicKnockNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .ChatLogNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .InvalidContent(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .ConversationNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .UserNotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .KickOffByOtherClient(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))
        case .StdError(_ /* message is ignored*/):
            writeInt(&buf, Int32(12))
        case .WebsocketError(_ /* message is ignored*/):
            writeInt(&buf, Int32(13))
        case .Http(_ /* message is ignored*/):
            writeInt(&buf, Int32(14))
        case .Json(_ /* message is ignored*/):
            writeInt(&buf, Int32(15))
        case .UserCancel(_ /* message is ignored*/):
            writeInt(&buf, Int32(16))
        case .Storage(_ /* message is ignored*/):
            writeInt(&buf, Int32(17))
        case .Other(_ /* message is ignored*/):
            writeInt(&buf, Int32(18))

        
        }
    }
}


extension ClientError: Equatable, Hashable {}

extension ClientError: Error { }

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeAttachment: FfiConverterRustBuffer {
    typealias SwiftType = Attachment?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAttachment.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAttachment.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeContent: FfiConverterRustBuffer {
    typealias SwiftType = Content?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeContent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeContent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUser: FfiConverterRustBuffer {
    typealias SwiftType = User?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUser.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUser.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeConversation: FfiConverterRustBuffer {
    typealias SwiftType = [Conversation]

    public static func write(_ value: [Conversation], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeConversation.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Conversation] {
        let len: Int32 = try readInt(&buf)
        var seq = [Conversation]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeConversation.read(from: &buf))
        }
        return seq
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 24
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_restsend_sdk_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }

    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}